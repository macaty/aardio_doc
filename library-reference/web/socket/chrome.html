
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - web.socket.chrome 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - web.socket.chrome 库模块帮助文档</title> 
<link rel="stylesheet" href="../../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>web.socket.chrome 库模块帮助文档</h1>

<p><a id="web.socket.chrome"></a></p>

<h2>web.socket.chrome 成员列表</h2>

<p>chrome远程调试接口<br>
WebSocket / JSON-RPC 2.0 单线程异步客户端<br>
<a href="../../../../../../chromedevtools.github.io/devtools-protocol/index.htm" tppabs="https://chromedevtools.github.io/devtools-protocol/">chrome远程调试接口文档</a></p>

<p><a id="web.socket.chrome.lastRemoteDebuggingPort"></a></p>

<h3>web.socket.chrome.lastRemoteDebuggingPort</h3>

<p>最近连接的远程调试端口号，也可以使用些属性指定下次连接远程调试服务端使用的默认端口</p>

<p><a id="web.socket"></a></p>

<h2>web.socket 成员列表</h2>

<p><a id="web.socket.chrome"></a></p>

<h3>web.socket.chrome()</h3>

<p>创建chrome远程调试客户端  </p>

<p><a href="#websocketchromeClientObject">返回对象:websocketchromeClientObject</a></p>

<p><a id="websocketchromeClientObject"></a></p>

<h2>websocketchromeClientObject 成员列表</h2>

<p><a id="websocketchromeClientObject.?"></a></p>

<h3>websocketchromeClientObject.?</h3>

<p>远程对象名或远程方法名字,<br>
作为函数调用时返回一个调用对象,<br>
通过指定返回调用对象的 end 属性定义调用结束回调函数,例如:<br>
ret.end=function(result,err){  </p>

<p>}<br>
回调参数 result 为调用返回值,err 为错误信息,<br>
如果调和成功,err参数为null  </p>

<p><a href="jsonClient.html#WebSocketJsonClientObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/web/socket/jsonClient.html#WebSocketJsonClientObject">返回对象:WebSocketJsonClientObject</a></p>

<p><a id="websocketchromeClientObject.connect"></a></p>

<h3>websocketchromeClientObject.connect(&quot;ws://&quot;)</h3>

<p>重新连接到WebSocket服务端<br>
参数指定WebSocket服务端网址，例如 &quot;ws://localhost:7511&quot;<br>
如果不指定参数,则获取上次调用此函数指定的网址参数,<br>
如果之前也没有指定网址则尝试自动查找可用接口地址  </p>

<p>如果存在可用的远程接口地址,此函数返回true,否则返回null<br>
但返回true并不表示连接成功,应在open事件中判断是否连接成功  </p>

<p>chrome的远程调试接口必须是独占模式,<br>
chrome开发工具连上去了,再连接就会失败<br>
chrome在整个系统只能用一个端口，启动一个开发工具<br>
但是electron可以每个进程使用自己的端口,启动一个独立的远程调试接口</p>

<p><a id="websocketchromeClientObject.connectFirstDebuggingPage"></a></p>

<h3>websocketchromeClientObject.connectFirstDebuggingPage()</h3>

<p>连接到指定端口的首个有效调试页面对象,<br>
参数指定远程调试端口号，或者拥有remoteDebuggingPort属性的对象</p>

<p><a id="websocketchromeClientObject.eachDebuggingPage"></a></p>

<h3>websocketchromeClientObject.eachDebuggingPage(port)</h3>

<pre><code class="aardio language-aardio">for id,title,wsUrl,devtoolsUrl in websocketchromeClientObject.eachDebuggingPage(/*参数指定远程调试端口号，或者拥有remoteDebuggingPort属性的对象*/) {

}
</code></pre>

<p><a id="websocketchromeClientObject.getDebuggingInfo"></a></p>

<h3>websocketchromeClientObject.getDebuggingInfo()</h3>

<p>用于获取远程调试服务端信息<br>
参数指定远程调试端口号，或者拥有remoteDebuggingPort属性的对象<br>
返回的参数是一个数组,即使失败也会返回空数组<br>
每个元素是一个表</p>

<p><a id="websocketchromeClientObject.getDebuggingPages"></a></p>

<h3>websocketchromeClientObject.getDebuggingPages()</h3>

<p>用于获取所有可以远程调试的页面对象<br>
参数指定远程调试端口号，或者拥有remoteDebuggingPort属性的对象<br>
返回的参数是一个数组,即使失败也会返回空数组<br>
每个元素是页面信息表</p>

<p><a id="websocketchromeClientObject.isClosed"></a></p>

<h3>websocketchromeClientObject.isClosed()</h3>

<p>套接字是否已关闭</p>

<p><a id="websocketchromeClientObject.isConnected"></a></p>

<h3>websocketchromeClientObject.isConnected()</h3>

<p>套接字是否已连接并准备就绪(已与服务器握手成功)</p>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(&quot;close&quot;,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;close&quot;,function(e){  
    /*连接被关闭  
e.code为错误代码e.reason为错误原因*/  
})
</code></pre>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(&quot;error&quot;,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;error&quot;,function(err){  
    /*发生错误,err为错误信息*/  
})
</code></pre>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(&quot;fragment&quot;,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;fragment&quot;,function(msg){  
   /*收到分片数据  
第一个数据包使用msg.type指明类型,参考WebSocket协议规范  
后续数据包msg.type为0,最后一个数据包msg.fin为1  

如果不指定这个回调函数,则自动并接分片数据后触发onMessage事件*/   
})
</code></pre>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(&quot;message&quot;,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;message&quot;,function(msg){  
    /*收到服务端数据  
msg.type为1时msg.data为文本,  
否则msg.data为字节数组（buffer类型）*/  
})
</code></pre>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(&quot;open&quot;,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;open&quot;,function(){  
    /*已打开连接*/       
}
</code></pre>

<p><a id="websocketchromeClientObject.on"></a></p>

<h3>websocketchromeClientObject.on(method,proc)</h3>

<pre><code class="aardio language-aardio">websocketchromeClientObject.on(&quot;/*需要监听的Rpc通知事件名字*/&quot;,function(param){  

})
</code></pre>

<p><a id="websocketchromeClientObject.readyState"></a></p>

<h3>websocketchromeClientObject.readyState</h3>

<p>连接状态,<br>
0为等待连接,1为已连接并准备就绪,2为正在关闭,3为已关闭<br>
只有成功通过WebSocket协议握手以后readyState才会被置为1<br>
这与socket.readyState连接成功就会置为1是不同的</p>

<p><a id="websocketchromeClientObject.rpc"></a></p>

<h3>websocketchromeClientObject.rpc</h3>

<p>WebSocket客户端对象<br>
此对象的成员谨慎改动  </p>

<p><a href="#websocketjsonClientrpcObject">返回对象:websocketjsonClientrpcObject</a></p>

<p><a id="websocketchromeClientObject.waitForConnected"></a></p>

<h3>websocketchromeClientObject.waitForConnected(关联窗口句柄,超时)</h3>

<p>等待连接到远程调试接口<br>
所有参数可选,超时以毫秒为单位,  </p>

<p>如果没有找到有效的接口地址,<br>
此函数会自动发现嵌入electron的远程接口地址并重试连接  </p>

<p>连接成功返回true,失败返回false或null</p>

<p><a href="chrome.md" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/web/socket/chrome.md">Markdown 格式</a></p>

</body> 
</html>