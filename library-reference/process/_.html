
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - process 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - process 库模块帮助文档</title> 
<link rel="stylesheet" href="../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>process 库模块帮助文档</h1>

<p><details>  <summary>相关范例</summary>  <p>
范例程序 &gt; 进程
</p></details></p>

<p><a id="process"></a></p>

<h2>process 成员列表</h2>

<p>运行执行文件或关联文档。<br>
如果省略所有参数则打开当前进程<br>
失败则返回 null,错误信息,错误代码<br>
成功返回进程对象。  </p>

<p>个别系统 64 位程序，需要改用 process.wow64 启动以避免目录重定向。<br>
极个别系统程序，需要用 process.shell 函数创建 process 对象。</p>

<p><a id="process( ,系统命令行)"></a></p>

<h3>process( ,系统命令行)</h3>

<p>如果省略第一个参数,并仅指定命令行,则作为系统命令行启动运行</p>

<p><a id="process()"></a></p>

<h3>process()</h3>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="process(执行文件,命令行参数,STARTUPINFO)"></a></p>

<h3>process(执行文件,命令行参数,STARTUPINFO)</h3>

<p>命令行参数可以是字符串或由多个字符串组成的数组,<br>
数组参数调用 string.args.join 合并,<br>
不在双引号内、且包含空白或需要转义的参数转义处理后首尾添加双引号,<br>
命令参数最大长度为 32765 个字符。<br>
STARTUPINFO参数为process.STARTUPINFO 结构体,可选参数<br>
如果该参数是普通table对象.将自动创建为STARTUPINFO结构体</p>

<p><a id="process(执行文件,命令行参数,更多命令行参数,...)"></a></p>

<h3>process(执行文件,命令行参数,更多命令行参数,...)</h3>

<p>命令行参数可以是一个数组、一个或多个字符串参数,  </p>

<p>数组或多个命令行参数调用 string.args.join 合并,<br>
不在双引号内、且包含空白或需要转义的参数转义处理后首尾添加双引号,<br>
命令参数最大长度为 32765 个字符</p>

<p><a id="process(进程ID,权限)"></a></p>

<h3>process(进程ID,权限)</h3>

<p>打开指定ID的进程,<br>
参数@2可选用一个数值指定请求的权限，<br>
不指定权限时默认尝试 _PROCESS_ALL_ACCESS 权限,<br>
如果失败则尝试以 _SYNCHRONIZE 权限打开进程,<br>
_SYNCHRONIZE权限打开时只能使用 wait,waitOne函数,<br>
非管理权限进程创建管理权限进程时只能以_SYNCHRONIZE权限打开进程</p>

<p><a id="process(进程句柄,负责释放进程句柄)"></a></p>

<h3>process(进程句柄,负责释放进程句柄)</h3>

<p>使用指定的进程句柄创建进程对象,<br>
参数@2为可选参数,默认为true</p>

<p><a id="process.     ReadProcessMemory64"></a></p>

<h3>process.        ReadProcessMemory64</h3>

<pre><code class="aardio language-aardio">::Ntdll.api(&quot;NtWow64ReadVirtualMemory64&quot;,&quot;int(POINTER hProcess,LONG base,struct &amp;buf,long size,long &amp; retSize)&quot; )
</code></pre>

<p><a id="process. GetModuleFileNameEx"></a></p>

<h3>process.    GetModuleFileNameEx</h3>

<pre><code class="aardio language-aardio">Psapi.api(&quot;GetModuleFileNameEx&quot;,&quot;INT(pointer hProcess,pointer hModule,ustring&amp; lpFilename,INT size)&quot; )
</code></pre>

<p><a id="process. MEMORY_BASIC_INFORMATION"></a></p>

<h3>process.    MEMORY_BASIC_INFORMATION</h3>

<pre><code class="aardio language-aardio">class {
        addr BaseAddress;
        addr AllocationBase;
        INT AllocationProtect;
        INT RegionSize;
        INT State;
        INT Protect;
        INT Type;
    }
</code></pre>

<p><a id="process. THREADENTRY32"></a></p>

<h3>process.    THREADENTRY32</h3>

<pre><code class="aardio language-aardio">class {
    INT dwSize;
    INT cntUsage;
    INT th32ThreadID; // this thread
    INT th32OwnerProcessID; // Process this thread is associated with
    int tpBasePri;
    int tpDeltaPri;
    INT dwFlags;
    }
</code></pre>

<p><a id="process.::Advapi32 :"></a></p>

<h3>process.::Advapi32 :</h3>

<pre><code class="aardio language-aardio">..raw.loadDll(&quot;Advapi32.dll&quot;)
</code></pre>

<p><a id="process.CreateProcess"></a></p>

<h3>process.CreateProcess</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;CreateProcess&quot;,&quot;int(ustring app, ustring &amp;cmd, pointer processAttributes,pointer threadAttributes, bool inheritHandles, INT creationFlags,ustring environment, ustring lpCurrentDirectory, struct lpStartupInfo, struct&amp; lpProcessInformation )&quot;);
</code></pre>

<p><a id="process.CreateProcessWithLogonW"></a></p>

<h3>process.CreateProcessWithLogonW</h3>

<pre><code class="aardio language-aardio">::Advapi32.api(&quot;CreateProcessWithLogonW&quot;,&quot;int(ustring user,ustring domain,ustring pwd,INT flags,ustring app, ustring &amp;cmd, INT creationFlags,ustring environment, ustring lpCurrentDirectory, struct lpStartupInfo, struct&amp; lpProcessInformation )&quot;);
</code></pre>

<p><a id="process.FindExecutable"></a></p>

<h3>process.FindExecutable</h3>

<pre><code class="aardio language-aardio">::Shell32.api(&quot;FindExecutable&quot;,&quot;int(ustring file,ustring directory,ustring &amp;result)&quot;)
</code></pre>

<p><a id="process.GetExitCodeProcess"></a></p>

<h3>process.GetExitCodeProcess</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;GetExitCodeProcess&quot;,&quot;bool(POINTER hProcess,INT &amp;code)&quot;);
</code></pre>

<p><a id="process.GetPriorityClass"></a></p>

<h3>process.GetPriorityClass</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;GetPriorityClass&quot;,&quot;INT(POINTER hProcess&quot;);
</code></pre>

<p><a id="process.IsWow64Process"></a></p>

<h3>process.IsWow64Process</h3>

<pre><code class="aardio language-aardio">::Kernel32.api( &quot;IsWow64Process&quot;, &quot;bool(pointer hProcess,bool &amp;Wow64Process)&quot;);
</code></pre>

<p><a id="process.OpenProcess"></a></p>

<h3>process.OpenProcess</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;OpenProcess&quot;,&quot;pointer(INT desiredAccess,bool inherit,INT pid)&quot;)
</code></pre>

<p><a id="process.PROCESS_INFORMATION"></a></p>

<h3>process.PROCESS_INFORMATION</h3>

<pre><code class="aardio language-aardio">class {
        pointer hProcess;
        pointer hThread;
        INT dwProcessId;
        INT dwThreadId;
    }
</code></pre>

<p><a id="process.ReadProcessMemory"></a></p>

<h3>process.ReadProcessMemory</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;ReadProcessMemory&quot;,&quot;int(POINTER hProcess,addr base,struct &amp;buf,INT size,INT &amp; retSize)&quot; )
</code></pre>

<p><a id="process.ReadProcessMemoryByString"></a></p>

<h3>process.ReadProcessMemoryByString</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;ReadProcessMemory&quot;,&quot;int(POINTER hProcess,addr base,string &amp;buf,INT size,INT &amp; retSize)&quot; )
</code></pre>

<p><a id="process.ReadProcessMemoryByString64"></a></p>

<h3>process.ReadProcessMemoryByString64</h3>

<pre><code class="aardio language-aardio">::Ntdll.api(&quot;NtWow64ReadVirtualMemory64&quot;,&quot;int(POINTER hProcess,LONG base,string &amp;buf,long size,long &amp; retSize)&quot; )
</code></pre>

<p><a id="process.STARTUPINFO"></a></p>

<h3>process.STARTUPINFO</h3>

<pre><code class="aardio language-aardio">class {
        INT cb = 68;
        ustring reserved;
        ustring desktop;
        ustring title;
        INT x;
        INT y;
        INT xSize;
        INT ySize;
        INT xCountChars;
        INT yCountChars;
        INT fillAttribute;
        INT flags;
        WORD showWindow;
        WORD cbReserved2;
        ustring lpReserved2;
        pointer stdInput;
        pointer stdOutput;
        pointer stdError; 
        creationFlag = 0;
        inheritHandles;
    };
</code></pre>

<p><a id="process.STARTUPINFO"></a></p>

<h3>process.STARTUPINFO()</h3>

<p>创建进程启动参数  </p>

<p><a href="#startinfoObject">返回对象:startinfoObject</a></p>

<p><a id="process.SetPriorityClass"></a></p>

<h3>process.SetPriorityClass</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;SetPriorityClass&quot;,&quot;bool(POINTER hProcess,INT priorityClass)&quot;);
</code></pre>

<p><a id="process.SetProcessAffinityMask"></a></p>

<h3>process.SetProcessAffinityMask</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;SetProcessAffinityMask&quot;,&quot;INT(pointer hProcess,INT dwProcessAffinityMask)&quot; )
</code></pre>

<p><a id="process.TerminateProcess"></a></p>

<h3>process.TerminateProcess</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;TerminateProcess&quot;,&quot;int(pointer hProcess,INT exitCode)&quot;)
</code></pre>

<p><a id="process.Thread32First"></a></p>

<h3>process.Thread32First</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;Thread32First&quot;,&quot;int(pointer hsnap,struct&amp; lppe)&quot;)
</code></pre>

<p><a id="process.Thread32Next"></a></p>

<h3>process.Thread32Next</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;Thread32Next&quot;,&quot;int(pointer hsnap,struct&amp; lppe)&quot;)
</code></pre>

<p><a id="process.VirtualAllocEx"></a></p>

<h3>process.VirtualAllocEx</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;VirtualAllocEx&quot;,&quot;addr(POINTER hProcess ,addr addr,int dwSize,int flAllocationType,int flProtect)&quot;)
</code></pre>

<p><a id="process.VirtualFreeEx"></a></p>

<h3>process.VirtualFreeEx</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;VirtualFreeEx&quot;,&quot;int(POINTER hProcess,addr addr,int dwSize,int dwFreeType)&quot;)
</code></pre>

<p><a id="process.VirtualProtectEx"></a></p>

<h3>process.VirtualProtectEx</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;VirtualProtectEx&quot;,&quot;bool(POINTER hProcess,addr addr, INT dwSize, INT flNewProtect, INT &amp;lpflOldProtect )&quot;);
</code></pre>

<p><a id="process.VirtualQueryEx"></a></p>

<h3>process.VirtualQueryEx</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;VirtualQueryEx&quot;,&quot;INT(pointer hProcess,addr addr,struct&amp; buf,INT dwLength)&quot; )
</code></pre>

<p><a id="process.WaitForInputIdle"></a></p>

<h3>process.WaitForInputIdle</h3>

<pre><code class="aardio language-aardio">::User32.api(&quot;WaitForInputIdle&quot;,&quot;INT(pointer hProcess,INT dwMilliseconds)&quot;);
</code></pre>

<p><a id="process.WriteProcessMemory"></a></p>

<h3>process.WriteProcessMemory</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;WriteProcessMemory&quot;,&quot;int(POINTER hProcess,addr base,struct buf,INT size,INT &amp; retSize)&quot; )
</code></pre>

<p><a id="process.WriteProcessMemory64"></a></p>

<h3>process.WriteProcessMemory64</h3>

<pre><code class="aardio language-aardio">::Ntdll.api(&quot;NtWow64WriteVirtualMemory64&quot;,&quot;int(POINTER hProcess,LONG base,struct buf,long size,long &amp; retSize)&quot; )
</code></pre>

<p><a id="process.WriteProcessMemoryByString"></a></p>

<h3>process.WriteProcessMemoryByString</h3>

<pre><code class="aardio language-aardio">::Kernel32.api(&quot;WriteProcessMemory&quot;,&quot;int(POINTER hProcess,addr base,string buf,INT size,INT &amp; retSize)&quot; )
</code></pre>

<p><a id="process.WriteProcessMemoryByString64"></a></p>

<h3>process.WriteProcessMemoryByString64</h3>

<pre><code class="aardio language-aardio">::Ntdll.api(&quot;NtWow64WriteVirtualMemory64&quot;,&quot;int(POINTER hProcess,LONG base,string buf,long size,long &amp; retSize)&quot; )
</code></pre>

<p><a id="process.dup"></a></p>

<h3>process.dup(句柄,,目标进程句柄)</h3>

<p>复制句柄到目标进程句柄</p>

<p><a id="process.dup"></a></p>

<h3>process.dup(句柄,源进程句柄)</h3>

<p>从指定进程复制句柄到当前进程</p>

<p><a id="process.dup"></a></p>

<h3>process.dup(句柄,源进程句柄,目标进程句柄)</h3>

<p>进程句柄参数省略则为当前进程句柄<br>
函数支持更多可选参数如下:<br>
(句柄,源进程,目标进程,是否可继承,选项,安全访问级别)<br>
默认可继承,选项默认为_DUPLICATE_CLOSE_SOURCE | _DUPLICATE_SAME_ACCESS<br>
如果不指定最后一个参数</p>

<p><a id="process.each"></a></p>

<h3>process.each</h3>

<pre><code class="aardio language-aardio">for processEntry in process.each( &quot;.*.exe&quot; ) {   
//搜索进程，参数指定执行文件名（支持完全匹配与模式匹配，忽略大小写）  
    //io.print( processEntry.szExeFile  )  

}
</code></pre>

<p><a id="process.eachModule"></a></p>

<h3>process.eachModule</h3>

<pre><code class="aardio language-aardio">for moduleEntry in process.eachModule(/*进程ID*/) {   
//io.print( moduleEntry.szExePath  )  

}
</code></pre>

<p><a id="process.eachThread"></a></p>

<h3>process.eachThread</h3>

<pre><code class="aardio language-aardio">for threadEntry in process.eachThread(/*进程ID*/) {   
//io.print( threadEntry.th32ThreadID  )  

}
</code></pre>

<p><a id="process.eachWindow"></a></p>

<h3>process.eachWindow(执行文件名,类名,标题)</h3>

<pre><code class="aardio language-aardio">for hwnd in process.eachWindow( &quot;.*.exe&quot; ) {  
    /*搜索进程主窗口，所有参数可选。  
参数 @1 指定应指定进程执行文件名而非文件路径，  
所有参数支持完全匹配与模式匹配，忽略大小写。  
不指定类名或标题时忽略隐藏窗口。*/  
}
</code></pre>

<p><a id="process.emptyWorkingSet"></a></p>

<h3>process.emptyWorkingSet()</h3>

<p>将工作集中的内存尽可能移动到页面文件中,<br>
应发在最小化或程序空闲内存确实暂不需要使用时调用,<br>
不应频繁调用此函数</p>

<p><a id="process.environment"></a></p>

<h3>process.environment()</h3>

<p>返回当前进程的所有环境变量组成的字符串<br>
键与值之间使用等号分隔,每个键值对中间以<code>&#39;\0&#39;</code>分隔<br>
尾部没有<code>&#39;\0&#39;</code></p>

<p><a id="process.execute"></a></p>

<h3>process.execute</h3>

<p>运行exe应用程序,成功返回进程ID,<br>
参数详细用法请参考本函数源码以及 WINAPI 中 ShellExecuteEx 函数用法<br>
运行 UWP 应用请使用 com.shell.activateApp 函数  </p>

<p>raw.execute 提供了与本函数类似的功能。  </p>

<p>个别系统 64 位程序，需要改用 process.wow64.execute 以避免目录重定向。</p>

<p><a id="process.execute"></a></p>

<h3>process.execute(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,operation=&quot;open&quot;,showCmd,workDir,hwnd)</h3>

<p>参数 @1 为程序路径或系统命令。  </p>

<p>可选参数 @parameters 可以是字符串或字符串数组，用于指定启动参数。<br>
如果指定数组则由 string.args.join 自动处理转义并支持命名参数。<br>
如果启动参数只指定一个文件路径，为避免可能包含空格或以反斜杆结尾等需要转义的情况，<br>
建议写为 process.execute(exePath,{path}) 这种格式，让 aardio 自动处理转义。  </p>

<p>可选参数 @operation 为启动模式<br>
可选参数 @showCmd 使用 <em>SW</em> 前缀常量，与win.show参数用法相同。<br>
可选参数 @workdir 为工作目录<br>
可选参数 @hwnd 可指定父窗口句柄</p>

<p><a id="process.executeEx"></a></p>

<h3>process.executeEx(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,operation=&quot;open&quot;,showCmd,workDir,hwnd,fmask)</h3>

<p>运行 EXE 应用程序,返回 SHELLEXECUTEINFO 结构体,<br>
参数 @1 指定要运行的执行程序路径,<br>
参数 @2 可用一个字符串或字符串数组指定启动参数。<br>
所有参数用法与 process.execute 函数相同。<br>
关于 @fmask 详细用法请参考本函数源码（一般用不到）。<br>
除参数 @1 以外所有参数可选</p>

<p><a id="process.executeInvoke"></a></p>

<h3>process.executeInvoke(path, parameters,operation,showCmd,workDir,hwnd)</h3>

<p>创建临时的后台线程运行应用程序<br>
在打开程序前退出主线程可能无法执行操作,<br>
参数与 process.execute 函数用法一样,除指定参数@1或参数@2,其他所有参数可选</p>

<p><a id="process.executeWait"></a></p>

<h3>process.executeWait(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,operation=&quot;open&quot;,showCmd,workDir=&quot;,hwnd=0)</h3>

<p>运行exe应用程序<br>
并等待应用程序关闭<br>
除参数@1以外所有参数可选，所有参数用法与 process.execute 相同</p>

<p><a id="process.executeWaitInput"></a></p>

<h3>process.executeWaitInput(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,operation=&quot;open&quot;,showCmd,workDir=&quot;,hwnd=0)</h3>

<p>运行exe应用程序<br>
并等待进程初始化完成并接受输入<br>
除参数@1以外所有参数可，所有参数用法与 process.execute 相同</p>

<p><a id="process.explore"></a></p>

<h3>process.explore(path,args,...)</h3>

<p>使用资源管理器（Explorer.exe）打开文件或目录。  </p>

<p>第一个参数 @path 指定文件路径，可为空值（ null ）。<br>
注意 Explorer.exe 不解析标准的命令行参数转义符，这一点与其他程序不同。<br>
如参数 @path 尾部有双反斜杆<code>\\</code>则为无效路径并打开默认目录（打开我的文档，XP系统报错）。<br>
如参数 @path 指定为 &quot;,&quot;或&quot;file:&quot; 则打开“此电脑（This PC）”。<br>
如参数 @path 使用<code>shell:::</code>前缀则可以指定特殊路径的 CLSID。  </p>

<p>可用第二个参数 @args 或更多参数指定 Explorer.exe 命令行选项，<br>
例如指定  &quot;/select&quot; 在资源管理器选择指定路径。<br>
注意 &quot;/n&quot; 等选项在新系统中是无意义的，Explorer 将总是打开新窗口。  </p>

<p>内置函数 raw.explore 与 process.explore 用法相同。</p>

<p><a id="process.exploreSelect"></a></p>

<h3>process.exploreSelect(&quot;字符串参数&quot;)</h3>

<p>打开资源管理器，选定参数 @1 指定的文件路径。</p>

<p><a id="process.find"></a></p>

<h3>process.find(&quot;字符串参数&quot;)</h3>

<p>查找进程并返回进程对象。<br>
参数 @1 指定要查找的进程启动文件名,注意应指定文件名而非文件路径,<br>
文件名参数支持完全匹配与模式匹配，忽略大小写</p>

<p><a id="process.find"></a></p>

<h3>process.find()</h3>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="process.findExe"></a></p>

<h3>process.findExe(&quot;字符串参数&quot;)</h3>

<p>查找文件关联的可执行程序</p>

<p><a id="process.findId"></a></p>

<h3>process.findId(&quot;字符串参数&quot;)</h3>

<p>查找进程并返回进程 ID。<br>
参数 @1 指定要查找的进程启动文件名,注意应指定文件名而非文件路径,<br>
文件名参数支持完全匹配与模式匹配，忽略大小写</p>

<p><a id="process.findWindow"></a></p>

<h3>process.findWindow</h3>

<p>查找进程并返回进程主窗口句柄。</p>

<p><a id="process.findWindow"></a></p>

<h3>process.findWindow(执行文件名,类名,标题)</h3>

<p>所有参数可选。<br>
参数 @1 指定应指定进程执行文件名而非文件路径，<br>
所有参数支持完全匹配与模式匹配，忽略大小写。<br>
不指定类名或标题时忽略隐藏窗口。</p>

<p><a id="process.firstThreadId"></a></p>

<h3>process.firstThreadId(进程ID)</h3>

<p>返回进程的首个线程 ID</p>

<p><a id="process.getHandle"></a></p>

<h3>process.getHandle()</h3>

<p>获取当前进程伪句柄</p>

<p><a id="process.getId"></a></p>

<h3>process.getId()</h3>

<p>获取当前进程 ID</p>

<p><a id="process.getInfo"></a></p>

<h3>process.getInfo</h3>

<p>获取进程信息</p>

<p><a id="process.getInfo"></a></p>

<h3>process.getInfo()</h3>

<p><a href="#ProcessInfoObject">返回对象:ProcessInfoObject</a></p>

<p><a id="process.getInfo"></a></p>

<h3>process.getInfo(handle)</h3>

<p>获取进程信息，参数 @1 指定进程句柄</p>

<p><a id="process.getInfo"></a></p>

<h3>process.getInfo(handle,infoClass,infoStruct)</h3>

<p>参数 @1 指定进程句柄。<br>
如果参数 infoClass 指定非 null 数值，<br>
并且 infoStruct 指定结构体。<br>
在 Win8 以及之后系统获取信息到该结构体。<br>
成功返回原结构体</p>

<p><a id="process.getParent"></a></p>

<h3>process.getParent()</h3>

<p>获取父进程对象。<br>
参数@1可选用一个数值指定请求的权限，<br>
不指定权限时默认尝试 _PROCESS_ALL_ACCESS 权限,<br>
如果失败则尝试以 _SYNCHRONIZE 权限打开进程。  </p>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="process.getParentId"></a></p>

<h3>process.getParentId()</h3>

<p>获取父进程 ID</p>

<p><a id="process.getPath"></a></p>

<h3>process.getPath(进程ID)</h3>

<p>返回执行程序文件完整路径</p>

<p><a id="process.is"></a></p>

<h3>process.is()</h3>

<p>传入参数是否 process 对象</p>

<p><a id="process.isExe"></a></p>

<h3>process.isExe(&quot;字符串参数&quot;)</h3>

<p>检测目标文件是否可执行文件。<br>
如果是可执行文件返回&quot;PE32&quot;或&quot;PE64&quot;<br>
第二个返回值为子系统,GUI为2,CUI为3<br>
失败或参数为 null 返回 null</p>

<p><a id="process.joinArguments"></a></p>

<h3>process.joinArguments</h3>

<p>用于安全地合并命令行参数，并自动处理转义字符。<br>
此函数实际指向 string.args.join 函数。</p>

<p><a id="process.joinArguments"></a></p>

<h3>process.joinArguments(参数表,...)</h3>

<p>可传入一个参数表（可包含数组成员）或多个非 null 参数。  </p>

<p>如果传入参数是一个表对象（可包含数组），<br>
参数表将自动合并为单个命令行参数并返回一个字符串值。<br>
表中以键名以 - 或 / 开头的名值对自动合并为命令行参数。  </p>

<p>数组成员也会合并到命令行，但名值对参数总是置于数组参数之前。<br>
如果数组成员也是表对象，则仍调用此函数直接转换为字符串（不再转义）。<br>
其他数组或命名参数值用 tostring 转换为字符串，按需添加引号进行必要的转义。<br>
不在双引号内、且含空白字符或 ^ | &amp; 等字符的参数转义后置入双引号。</p>

<p><a id="process.kill"></a></p>

<h3>process.kill</h3>

<p>查找并关闭进程,<br>
注意有些进程需要管理权限才能找到,<br>
例如资源管理器进程 &quot;explorer.exe&quot; 无管理权限有时会失败,<br>
在代码第一行添加//RUNAS//可申请管理权限</p>

<p><a id="process.kill"></a></p>

<h3>process.kill(exePath,restart)</h3>

<p>查找所有同名 exe 文件的进程，并关闭进程。<br>
参数 @exePath 支持完全匹配与模式匹配,忽略大小写。<br>
返回进程的完整路径。  </p>

<p>如果 @restart 参数为 true，<br>
则杀进程成功后立即重新启动该进程</p>

<p><a id="process.kill"></a></p>

<h3>process.kill(pid)</h3>

<p>使用参数@pid指定进程ID,关闭该进程</p>

<p><a id="process.openUrl"></a></p>

<h3>process.openUrl()</h3>

<p>调用默认浏览器打开网址,用于窗口程序,<br>
如果不用这个方法创建线程去打开网址,可能会出现界面卡顿不流畅的现象,<br>
在打开网址前退出主线程可能无法执行操作<br>
控制台程序应调用 process.execute 以避免后台线程不能阻止控制台关闭</p>

<p><a id="process.regAs"></a></p>

<h3>process.regAs(<code>命令参数</code>)</h3>

<p>以管理权限执行 reg 命令</p>

<p><a id="process.shell"></a></p>

<h3>process.shell</h3>

<p>并运行应用程序，返回 process 进程对象。<br>
个别系统 64 位程序，需要改用 process.wow64.shell 以禁用目录重定向。</p>

<p><a id="process.shell"></a></p>

<h3>process.shell(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,operation=&quot;open&quot;,showCmd,workDir,hwnd,fmask)</h3>

<p>参数 @1 指定要运行的执行程序路径,<br>
参数 @2 可用一个字符串或字符串数组指定启动参数,<br>
所有参数用法与 process.execute 函数相同。<br>
关于 @fmask 详细用法请参考本函数源码（一般用不到）。<br>
除参数 @1 以外所有参数可选</p>

<p><a id="process.shell"></a></p>

<h3>process.shell()</h3>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="process.shellAs"></a></p>

<h3>process.shellAs</h3>

<p>以管理权限运行 EXE 应用程序,返回进程对象</p>

<p><a id="process.shellAs"></a></p>

<h3>process.shellAs(&quot;字符串参数&quot;, parameters=&quot;字符串参数&quot;,showCmd,workDir,hwnd,fmask)</h3>

<p>参数 @1 指定要运行的执行程序路径,<br>
参数 @2 可用一个字符串或字符串数组指定启动参数。<br>
所有参数用法与 process.execute 函数相同。<br>
关于 @fmask 详细用法请参考本函数源码（一般用不到）。<br>
除参数 @1 以外所有参数可选</p>

<p><a id="process.shellAs"></a></p>

<h3>process.shellAs()</h3>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="process.workDir"></a></p>

<h3>process.workDir</h3>

<p>创建进程默认工作目录，<br>
默认值为&quot;/&quot;，也即应用程序根目录。  </p>

<p>启动程序路径可直接访问时默认工作目录为应用程序所在目录，<br>
反之启动程序路径传入 io.exist 返回 false 则默认工作目录为 process.workDir，<br>
一般不建议改变默认工作目录，<br>
更好的选择是在创建进程的选项参数中指定 workDir</p>

<p><a id="processObject"></a></p>

<h2>processObject 成员列表</h2>

<p><a id="processObject.asm"></a></p>

<h3>processObject.asm(机器码数组,函数原型,调用约定)</h3>

<p>使用table数组指定任意个机器码参数,使用分号隔开,<br>
机器码可以是字符串,结构体,数值或指针,<br>
函数原型可省略,调用约定默认为&quot;cdecl&quot;</p>

<p><a id="processObject.asmCdecl"></a></p>

<h3>processObject.asmCdecl(函数原型,任意多个机器码参数)</h3>

<p>写入机器码返回函数对象<br>
请参考:aardio工具-&gt;其他编译器-&gt;INTEL汇编语言-&gt;汇编转机器码</p>

<p><a id="processObject.asmStdcall"></a></p>

<h3>processObject.asmStdcall(函数原型,任意多个机器码参数)</h3>

<p>写入机器码返回函数对象<br>
请参考:aardio工具-&gt;其他编译器-&gt;INTEL汇编语言-&gt;汇编转机器码</p>

<p><a id="processObject.asmThiscall"></a></p>

<h3>processObject.asmThiscall(函数原型,任意多个机器码参数)</h3>

<p>写入机器码返回函数对象<br>
请参考:aardio工具-&gt;其他编译器-&gt;INTEL汇编语言-&gt;汇编转机器码</p>

<p><a id="processObject.assignToJobObject"></a></p>

<h3>processObject.assignToJobObject(process.job.limitKill)</h3>

<p>绑定到作业对象,成功返回 true<br>
作业对象示例请参考标准库 process.job.limitKill 的源码。<br>
也可直接调用 killOnExit 函数绑定 process.job.limitKill</p>

<p><a id="processObject.closeMainWindow"></a></p>

<h3>processObject.closeMainWindow()</h3>

<p>关闭进程的主窗口，忽略隐藏窗口</p>

<p><a id="processObject.ctrlEvent"></a></p>

<h3>processObject.ctrlEvent(0)</h3>

<p>发送Ctrl+C(SIGINT信号)<br>
信号将传递到与目标进程控制台连接的所有非分离控制台进程<br>
64位目标进程会导致当前控制台暂时关闭</p>

<p><a id="processObject.ctrlEvent"></a></p>

<h3>processObject.ctrlEvent(1)</h3>

<p>发送Ctrl+Break(SIGBREAK信号)<br>
信号将传递到与目标进程控制台连接的所有非分离控制台进程<br>
64位目标进程会导致当前控制台暂时关闭</p>

<p><a id="processObject.eachModule"></a></p>

<h3>processObject.eachModule</h3>

<pre><code class="aardio language-aardio">for moduleEntry in processObject.eachModule() {   
//此函数仅支持 32 位进程  

}
</code></pre>

<p><a id="processObject.eachQuery"></a></p>

<h3>processObject.eachQuery(开始地址,搜索内存长度,搜索数据)</h3>

<pre><code class="aardio language-aardio">for( curMemAddr,curMemSize,strResult,i,j,remainSize in processObject.eachQuery(  , ,&quot;/*搜索模式*/&quot; ) ){  

}
</code></pre>

<p><a id="processObject.eachThread"></a></p>

<h3>processObject.eachThread</h3>

<pre><code class="aardio language-aardio">for threadEntry in processObject.eachThread() {   
//io.print( threadEntry.th32ThreadID  )  

}
</code></pre>

<p><a id="processObject.emptyWorkingSet"></a></p>

<h3>processObject.emptyWorkingSet()</h3>

<p>将工作集中的内存尽可能移动到页面文件中,<br>
可在最小化或程序空闲时调用以释放活动内存，<br>
不建议频繁调用此函数</p>

<p><a id="processObject.free"></a></p>

<h3>processObject.free()</h3>

<p>释放进程对象。<br>
不是关闭进程,仅仅是释放对进程的控制句柄。</p>

<p><a id="processObject.getExitCode"></a></p>

<h3>processObject.getExitCode()</h3>

<p>该函数调用成功有两个返回值:进程退出代码,进程是否已退出</p>

<p><a id="processObject.getInfo"></a></p>

<h3>processObject.getInfo</h3>

<p>获取进程信息</p>

<p><a id="processObject.getInfo"></a></p>

<h3>processObject.getInfo()</h3>

<p>获取进程信息</p>

<p><a href="#ProcessInfoObject">返回对象:ProcessInfoObject</a></p>

<p><a id="processObject.getInfo"></a></p>

<h3>processObject.getInfo(infoClass,infoStruct)</h3>

<p>如果参数 infoClass 指定非 null 数值，<br>
并且 infoStruct 指定结构体。<br>
在 Win8 以及之后系统获取信息到该结构体。<br>
成功返回原结构体。  </p>

<p>此用法内部调用 ::Kernel32.GetProcessInformation<br>
细节请参考该 API 文档</p>

<p><a id="processObject.getMainWindow"></a></p>

<h3>processObject.getMainWindow()</h3>

<p>返回进程的主窗口以及窗口进程 ID，找不到则搜寻子进程主窗口。<br>
查找时忽略隐藏窗口。  </p>

<p>也可以调用 winex.mainWindows 获取主窗口。<br>
winex.mainWindows 查找规则略有不同，请参考源码</p>

<p><a id="processObject.getMainWindow"></a></p>

<h3>processObject.getMainWindow(类名,标题)</h3>

<p>返回进程的指定类名的主窗口以及窗口进程 ID，找不到则搜寻子进程主窗口。<br>
类名与标题支持完全匹配与模式匹配，忽略大小写。<br>
所有参数可选，不指定类名或标题时忽略隐藏窗口。</p>

<p><a id="processObject.getModuleBaseAddress"></a></p>

<h3>processObject.getModuleBaseAddress(模块名)</h3>

<p>返回模块基址。<br>
模块名忽略大小写,<br>
不指定模块名则返回应用程序基址。  </p>

<p>此函数仅支持 32 位程序。<br>
64位进程返回 math.size64 对象（暂不支持指定模块名）</p>

<p><a id="processObject.getParent"></a></p>

<h3>processObject.getParent()</h3>

<p>获取父进程对象。<br>
参数@1可选用一个数值指定请求的权限，<br>
不指定权限时默认尝试 _PROCESS_ALL_ACCESS 权限,<br>
如果失败则尝试以 _SYNCHRONIZE 权限打开进程。  </p>

<p><a href="_.html#processObject" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.html#processObject">返回对象:processObject</a></p>

<p><a id="processObject.getParentId"></a></p>

<h3>processObject.getParentId()</h3>

<p>获取父进程 ID</p>

<p><a id="processObject.getPath"></a></p>

<h3>processObject.getPath()</h3>

<p>返回执行程序文件完整路径。<br>
如果该进程以管理权限运行，<br>
则调用函数的进程也必须以管理权限运行<br>
才能获取到路径</p>

<p><a id="processObject.getPriorityClass"></a></p>

<h3>processObject.getPriorityClass()</h3>

<p>返回进程优先级</p>

<p><a id="processObject.getUiInfo"></a></p>

<h3>processObject.getUiInfo()</h3>

<p>获取UI线程窗口焦点,光标等信息  </p>

<p><a href="#guithreadinfoObject">返回对象:guithreadinfoObject</a></p>

<p><a id="processObject.handle"></a></p>

<h3>processObject.handle</h3>

<p>进程句柄</p>

<p><a id="processObject.id"></a></p>

<h3>processObject.id</h3>

<p>进程 ID</p>

<p><a id="processObject.isWow64"></a></p>

<h3>processObject.isWow64()</h3>

<p>进程是否在64位系统上运行的32进程</p>

<p><a id="processObject.isX64"></a></p>

<h3>processObject.isX64()</h3>

<p>是否64位进程</p>

<p><a id="processObject.kill"></a></p>

<h3>processObject.kill()</h3>

<p>杀除进程</p>

<p><a id="processObject.killOnExit"></a></p>

<h3>processObject.killOnExit()</h3>

<p>主进程退出时自动退出此进程</p>

<p><a id="processObject.malloc"></a></p>

<h3>processObject.malloc(长度)</h3>

<p>在目标进程分配内存空间</p>

<p><a id="processObject.malloc"></a></p>

<h3>processObject.malloc(长度,访问类型)</h3>

<p>在目标进程分配内存空间</p>

<p><a id="processObject.malloc"></a></p>

<h3>processObject.malloc(长度,访问类型,分配类型)</h3>

<p>在目标进程分配内存空间</p>

<p><a id="processObject.mfree"></a></p>

<h3>processObject.mfree(指针)</h3>

<p>释放malloc成员函数分配的内存指针</p>

<p><a id="processObject.mfree"></a></p>

<h3>processObject.mfree(指针,释放长度,0x4000)</h3>

<p>释放malloc成员函数分配的内存指针<br>
不建议手工指定长度</p>

<p><a id="processObject.protect"></a></p>

<h3>processObject.protect(内存地址,4/*_PAGE_READWRITE*/,1)</h3>

<p>修改内存保护属性,返回原来的保护属性,<br>
第三个参数指定内存长度</p>

<p><a id="processObject.query"></a></p>

<h3>processObject.query(开始地址,搜索内存长度,搜索数据)</h3>

<p>查找下一个有效内存地址,所有参数可选,<br>
搜索数据可以是字符串或结构体<br>
返回值: curMemAddr,curMemSize,strResult,i,j,remainSize</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址)</h3>

<p>读取一个int整数,32位<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;BYTE&quot;)</h3>

<p>读取一个字节,8位无符号<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;INT&quot;)</h3>

<p>读取一个int整数,32位无符号<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;LONG&quot;)</h3>

<p>读取一个long类型整数,64位无符号<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;WORD&quot;)</h3>

<p>读取一个word类型整数,16位无符号<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;byte&quot;)</h3>

<p>读取一个字节,8位<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;long&quot;)</h3>

<p>读取一个long类型整数,64位<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumber"></a></p>

<h3>processObject.readNumber(内存地址,&quot;word&quot;)</h3>

<p>读取一个word类型整数,16位<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readNumberPtr"></a></p>

<h3>processObject.readNumberPtr(内存地址)</h3>

<p>读取 int 整数的指针，<br>
然后用在指针指向的内存读取读取数值。<br>
可用参数 @2 指定原生类型，用法同 readNumber 函数。</p>

<p><a id="processObject.readPtr"></a></p>

<h3>processObject.readPtr()</h3>

<p>读取指针地址。<br>
64 位进程读取 8 字节并返回 math.size64 对象。<br>
32 位进程读取 4 字节并返回数值。</p>

<p><a id="processObject.readString"></a></p>

<h3>processObject.readString(内存地址,长度)</h3>

<p>读取定长字符串<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readStringPtr"></a></p>

<h3>processObject.readStringPtr(内存地址,长度)</h3>

<p>在参数指定的地址读取字符串指针，<br>
然后用在指针指向的内存读取字符串。</p>

<p><a id="processObject.readStringUtf16"></a></p>

<h3>processObject.readStringUtf16(内存地址,长度)</h3>

<p>读取定长 UTF-16 字符串（ustring），<br>
返回字符串转换为 UTF-8 编码。<br>
注意长度以字符为单位<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readStringUtf16Ptr"></a></p>

<h3>processObject.readStringUtf16Ptr(内存地址,长度)</h3>

<p>在参数指定的地址读取字符串指针，<br>
然后用在指针指向的内存读取定长 UTF-16 字符串（ustring）。<br>
返回字符串转换为UTF8编码。<br>
注意长度以字符为单位</p>

<p><a id="processObject.readStruct"></a></p>

<h3>processObject.readStruct(内存地址,结构体)</h3>

<p>读取定义的结构体<br>
打开进程需要指定 _PROCESS_VM_READ 权限</p>

<p><a id="processObject.readStructPtr"></a></p>

<h3>processObject.readStructPtr(内存地址,结构体)</h3>

<p>在参数指定的地址读取结构体指针，<br>
然后用在指针指向的内存读取结构体</p>

<p><a id="processObject.remoteApi"></a></p>

<h3>processObject.remoteApi</h3>

<p>在外部进程内创建远程调用函数</p>

<p><a id="processObject.remoteApi("void"></a></p>

<h3>processObject.remoteApi(&quot;void()&quot;,&quot;dll名&quot;,&quot;函数名&quot;)</h3>

<p>参数(函数原型,加载DLL模块名,函数名,调用约定)<br>
不指定调用约定时默认使用stdcall调用约定<br>
不会在API函数名字后面自动添加或移除&quot;A&quot;,&quot;W&quot;编码声明后缀,<br>
并且要注意搜索DLL时默认搜索路径包含目标EXE所在目录,而非当前EXE目录</p>

<p><a id="processObject.remoteApi("void"></a></p>

<h3>processObject.remoteApi(&quot;void()&quot;,&quot;dll名&quot;,&quot;函数名&quot;,&quot;cdecl,borland&quot;)</h3>

<p>参数(函数原型,加载DLL模块名,函数名,调用约定)<br>
不会在API函数名字后面自动添加或移除&quot;A&quot;,&quot;W&quot;编码声明后缀,<br>
并且要注意搜索DLL时默认搜索路径包含目标EXE所在目录,而非当前EXE目录</p>

<p><a id="processObject.remoteApi("void"></a></p>

<h3>processObject.remoteApi(&quot;void()&quot;,CALL地址,调用约定)</h3>

<p>参数(函数原型,CALL地址,调用约定)<br>
不指定调用约定在数时默认使用stdcall调用约定</p>

<p><a id="processObject.remoteApi("void"></a></p>

<h3>processObject.remoteApi(&quot;void(INT thisAddr)&quot;,&quot;dll名&quot;,&quot;函数名&quot;,&quot;thiscall&quot;)</h3>

<p>参数(函数原型,加载DLL模块名,函数名,调用约定)<br>
thiscall使用第一个参数指定this指针地址<br>
不会在API函数名字后面自动添加或移除&quot;A&quot;,&quot;W&quot;编码声明后缀,<br>
并且要注意搜索DLL时默认搜索路径包含目标EXE所在目录,而非当前EXE目录</p>

<p><a id="processObject.resume"></a></p>

<h3>processObject.resume()</h3>

<p>恢复运行</p>

<p><a id="processObject.sendMessage"></a></p>

<h3>processObject.sendMessage(hwnd,message,wParam,lParam)</h3>

<p>向外部进程窗口发送消息<br>
lParam如果是结构体则复制到目标进程内存,<br>
结构体如果包含指针应当自行调用 process.malloc 分配内存并复制<br>
发送消息涉及的用法太多,尤其是涉及到访问外部进程内存,<br>
所涉及的知识量不能通过看几句函数说明获得,<br>
普通用户请不要学习或使用此函数</p>

<p><a id="processObject.setAffinity"></a></p>

<h3>processObject.setAffinity(1)</h3>

<p>指定进程运行的CPU内核</p>

<p><a id="processObject.setInfo"></a></p>

<h3>processObject.setInfo(infoClass,infoStruct)</h3>

<p>设置进程信息，成功返回 true。<br>
infoClass 指定数值，infoStruct 指定结构体。<br>
此函数内部调用 ::Kernel32.SetProcessInformation 。<br>
详细用法请参考 API 文档。<br>
在低于 Win8 的系统不执行操作</p>

<p><a id="processObject.setPriorityClass"></a></p>

<h3>processObject.setPriorityClass(0x80/*_HIGH_PRIORITY_CLASS*/)</h3>

<p>设置进程优先级</p>

<p><a id="processObject.stillActive"></a></p>

<h3>processObject.stillActive()</h3>

<p>进程是否仍在运行</p>

<p><a id="processObject.suspend"></a></p>

<h3>processObject.suspend()</h3>

<p>暂停进程</p>

<p><a id="processObject.terminate"></a></p>

<h3>processObject.terminate()</h3>

<p>强行终止进程<br>
可在参数中指定退出代码</p>

<p><a id="processObject.tid"></a></p>

<h3>processObject.tid</h3>

<p>返回进程的主线程 ID</p>

<p><a id="processObject.wait"></a></p>

<h3>processObject.wait()</h3>

<p>等待进程关闭,<br>
可选使用一个毫秒值参数设定超时<br>
超时或失败返回 false,<br>
进程已退出则返回值1为true,返回值2为退出代码</p>

<p><a id="processObject.waitMainWindow"></a></p>

<h3>processObject.waitMainWindow</h3>

<p>等待并返回进程主窗口以及窗口进程ID。<br>
也可调用 winex.mainWindows 且指定参数 @2 为 true 以等待主窗口。<br>
winex.mainWindows 查找规则略有不同，请参考源码</p>

<p><a id="processObject.waitMainWindow"></a></p>

<h3>processObject.waitMainWindow(类名,等待窗口句柄)</h3>

<p>等待并返回进程主窗口以及窗口进程ID。<br>
所有参数可选。<br>
可选指定要等待的类名，类名支持完全匹配与模式匹配，忽略大小写。<br>
不指定类名时忽略隐藏窗口,<br>
可选指定等待窗口句柄,该窗口关闭时些函数不再等待并直接返回结果</p>

<p><a id="processObject.waitOne"></a></p>

<h3>processObject.waitOne()</h3>

<p>等待进程关闭,不阻塞UI消息循环,<br>
可选使用一个毫秒值参数设定超时<br>
超时或失败返回 false,<br>
进程已退出则返回值1为true,返回值2为退出代码</p>

<p><a id="processObject.write"></a></p>

<h3>processObject.write(内存地址,任意个字符串或结构体参数)</h3>

<p>写入数据,成功返回写入尾部内存地址,<br>
失败返回空</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0)</h3>

<p>写入一个int整数,32位</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;BYTE&quot;)</h3>

<p>写入一个字节,8位无符号</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;INT&quot;)</h3>

<p>写入一个int整数,32位无符号</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;LONG&quot;)</h3>

<p>写入一个long类型整数,64位无符号</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;WORD&quot;)</h3>

<p>写入一个word类型整数,16位无符号</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;byte&quot;)</h3>

<p>写入一个字节,8位</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;long&quot;)</h3>

<p>写入一个long类型整数,64位</p>

<p><a id="processObject.writeNumber"></a></p>

<h3>processObject.writeNumber(内存地址,0,&quot;word&quot;)</h3>

<p>写入一个word类型整数,16位</p>

<p><a id="processObject.writeString"></a></p>

<h3>processObject.writeString(内存地址,字符串,长度)</h3>

<p>写入字符串,长度为可选参数,<br>
省略内存地址参数则自动分配内存,<br>
该函数返回写入内存地址,写入长度</p>

<p><a id="processObject.writeStringUtf16"></a></p>

<h3>processObject.writeStringUtf16(内存地址,字符串)</h3>

<p>写入 UTF-16 字符串（ustring）。<br>
参数可以为默认的UTF8编码文本</p>

<p><a id="processObject.writeStruct"></a></p>

<h3>processObject.writeStruct(内存地址,结构体)</h3>

<p>写入定义的结构体,<br>
省略内存地址参数则自动分配内存,<br>
该函数返回写入内存地址,写入长度</p>

<p><a id="ProcessInfoObject"></a></p>

<h2>ProcessInfoObject 成员列表</h2>

<p><a id="ProcessInfoObject.exitStatus"></a></p>

<h3>ProcessInfoObject.exitStatus</h3>

<p>进程退出代码</p>

<p><a id="ProcessInfoObject.pebBaseAddress"></a></p>

<h3>ProcessInfoObject.pebBaseAddress</h3>

<p>PEB 地址,<br>
注意 64 位进程这里返回 math.size64 对象,<br>
32 位进程返回数值</p>

<p><a id="ProcessInfoObject.prarentId"></a></p>

<h3>ProcessInfoObject.prarentId</h3>

<p>父进程ID</p>

<p><a id="heapEntry"></a></p>

<h2>heapEntry 成员列表</h2>

<p><a id="heapEntry.dwAddress"></a></p>

<h3>heapEntry.dwAddress</h3>

<pre><code class="aardio language-aardio">Linear address of start of block
</code></pre>

<p><a id="heapEntry.dwBlockSize"></a></p>

<h3>heapEntry.dwBlockSize</h3>

<pre><code class="aardio language-aardio">Size of block in bytes
</code></pre>

<p><a id="heapEntry.dwFlags"></a></p>

<h3>heapEntry.dwFlags</h3>

<pre><code class="aardio language-aardio">dwLockCount =
</code></pre>

<p><a id="heapEntry.dwResvd"></a></p>

<h3>heapEntry.dwResvd</h3>

<pre><code class="aardio language-aardio">th32ProcessID = owning process
</code></pre>

<p><a id="heapEntry.dwSize"></a></p>

<h3>heapEntry.dwSize</h3>

<p>结构体大小;</p>

<p><a id="heapEntry.hHandle"></a></p>

<h3>heapEntry.hHandle</h3>

<pre><code class="aardio language-aardio">Handle of this heap block
</code></pre>

<p><a id="heapEntry.th32HeapID"></a></p>

<h3>heapEntry.th32HeapID</h3>

<pre><code class="aardio language-aardio">heap block is in
</code></pre>

<p><a id="heapList"></a></p>

<h2>heapList 成员列表</h2>

<p><a id="heapList.dwFlags"></a></p>

<h3>heapList.dwFlags</h3>

<pre><code class="aardio language-aardio">
</code></pre>

<p><a id="heapList.dwSize"></a></p>

<h3>heapList.dwSize</h3>

<p>结构体大小;</p>

<p><a id="heapList.th32HeapID"></a></p>

<h3>heapList.th32HeapID</h3>

<pre><code class="aardio language-aardio">heap (in owning process&#39;s context!)
</code></pre>

<p><a id="heapList.th32ProcessID"></a></p>

<h3>heapList.th32ProcessID</h3>

<pre><code class="aardio language-aardio">owning process
</code></pre>

<p><a id="moduleEntry"></a></p>

<h2>moduleEntry 成员列表</h2>

<p><a id="moduleEntry.GlblcntUsage"></a></p>

<h3>moduleEntry.GlblcntUsage</h3>

<pre><code class="aardio language-aardio">ProccntUsage =
</code></pre>

<p><a id="moduleEntry.dwSize"></a></p>

<h3>moduleEntry.dwSize</h3>

<p>结构体大小</p>

<p><a id="moduleEntry.modBaseAddr"></a></p>

<h3>moduleEntry.modBaseAddr</h3>

<p>模块基址;</p>

<p><a id="moduleEntry.modBaseSize"></a></p>

<h3>moduleEntry.modBaseSize</h3>

<p>hModule = 模块句柄</p>

<p><a id="moduleEntry.szExePath"></a></p>

<h3>moduleEntry.szExePath</h3>

<pre><code class="aardio language-aardio">
</code></pre>

<p><a id="moduleEntry.szModule"></a></p>

<h3>moduleEntry.szModule</h3>

<pre><code class="aardio language-aardio">0;
</code></pre>

<p><a id="moduleEntry.th32ModuleID"></a></p>

<h3>moduleEntry.th32ModuleID</h3>

<p>模块ID;</p>

<p><a id="moduleEntry.th32ProcessID"></a></p>

<h3>moduleEntry.th32ProcessID</h3>

<p>进程ID,INT数据类型</p>

<p><a id="processEntryObject"></a></p>

<h2>processEntryObject 成员列表</h2>

<p><a id="processEntryObject.cntThreads"></a></p>

<h3>processEntryObject.cntThreads</h3>

<p>此进程开启的线程计数</p>

<p><a id="processEntryObject.dwSize"></a></p>

<h3>processEntryObject.dwSize</h3>

<p>结构体长度，以字节为单位</p>

<p><a id="processEntryObject.pcPriClassBase"></a></p>

<h3>processEntryObject.pcPriClassBase</h3>

<p>进程优先级,INT数据类型</p>

<p><a id="processEntryObject.szExeFile"></a></p>

<h3>processEntryObject.szExeFile</h3>

<p>进程启动文件名,不是文件完整路径</p>

<p><a id="processEntryObject.th32ParentProcessID"></a></p>

<h3>processEntryObject.th32ParentProcessID</h3>

<p>父进程的 ID</p>

<p><a id="processEntryObject.th32ProcessID"></a></p>

<h3>processEntryObject.th32ProcessID</h3>

<p>进程ID,INT数据类型</p>

<p><a id="startinfoObject"></a></p>

<h2>startinfoObject 成员列表</h2>

<p><a id="startinfoObject.createNoWindow"></a></p>

<h3>startinfoObject.createNoWindow</h3>

<p>应用程序不创建控制台窗口</p>

<p><a id="startinfoObject.creationFlag"></a></p>

<h3>startinfoObject.creationFlag</h3>

<pre><code class="aardio language-aardio">startinfoObject.creationFlag = CREATE //创建进程的参数,参考API CreateProcess的说明
</code></pre>

<p><a id="startinfoObject.desktop"></a></p>

<h3>startinfoObject.desktop</h3>

<p>标识启动应用程序所在的桌面的名字</p>

<p><a id="startinfoObject.domain"></a></p>

<h3>startinfoObject.domain</h3>

<p>域名</p>

<p><a id="startinfoObject.environment"></a></p>

<h3>startinfoObject.environment</h3>

<p>新进程的环境变量<br>
以键值对组成的字符串,多个键值对间请以<code>&#39;\0&#39;</code>分隔<br>
键与值之间以=号分隔<br>
也可以传入包含键值对的表对象</p>

<p><a id="startinfoObject.fillAttribute"></a></p>

<h3>startinfoObject.fillAttribute</h3>

<p>控制台窗口使用的文本和背景颜色</p>

<p><a id="startinfoObject.flags"></a></p>

<h3>startinfoObject.flags</h3>

<pre><code class="aardio language-aardio">startinfoObject.flags = _STARTF_USE //指定结构体中哪些成员生效
</code></pre>

<p><a id="startinfoObject.inheritEnvironment"></a></p>

<h3>startinfoObject.inheritEnvironment</h3>

<p>如果此属性的值恒等于false,且同时指定了environment的值,<br>
那么创建的子进程不会继承父进程的环境变量<br>
此属性不指定值时默认值为true</p>

<p><a id="startinfoObject.inheritHandles"></a></p>

<h3>startinfoObject.inheritHandles</h3>

<p>默认值为真,所有有可被继承属性的内核对象都会被复制到子进程(实际上是内核对象引用计数加一)</p>

<p><a id="startinfoObject.logonFlags"></a></p>

<h3>startinfoObject.logonFlags</h3>

<p>登录选项,默认为 _LOGON_WITH_PROFILE</p>

<p><a id="startinfoObject.password"></a></p>

<h3>startinfoObject.password</h3>

<p>登录密码</p>

<p><a id="startinfoObject.processAttributes"></a></p>

<h3>startinfoObject.processAttributes</h3>

<p>SECURITY_ATTRIBUTES结构体指针,一般不建议设置<br>
如需设置请使用raw.malloc将结构体转换为指针</p>

<p><a id="startinfoObject.showWindow"></a></p>

<h3>startinfoObject.showWindow</h3>

<p>显示参数，<br>
支持以_SW_ 前缀的常量<br>
_SW_HIDE 表示隐藏窗口（默认值）。<br>
此属性用于指定是否显示控制台以外的窗口，<br>
flags 字段必须指定 _STARTF_USESHOWWINDOW 才会生效</p>

<p><a id="startinfoObject.stdError"></a></p>

<h3>startinfoObject.stdError</h3>

<p>标准错误输出(可用于创建管道)</p>

<p><a id="startinfoObject.stdInput"></a></p>

<h3>startinfoObject.stdInput</h3>

<p>标准输入（可用于创建管道）</p>

<p><a id="startinfoObject.stdOutput"></a></p>

<h3>startinfoObject.stdOutput</h3>

<p>标准输出（可用于创建管道）</p>

<p><a id="startinfoObject.suspended"></a></p>

<h3>startinfoObject.suspended</h3>

<p>是否休眠创建进程的主线程<br>
如果为真自动添加_CREATE_SUSPENDED参数</p>

<p><a id="startinfoObject.threadAttributess"></a></p>

<h3>startinfoObject.threadAttributess</h3>

<p>SECURITY_ATTRIBUTES结构体指针,一般不建议设置<br>
如需设置请使用raw.malloc将结构体转换为指针</p>

<p><a id="startinfoObject.title"></a></p>

<h3>startinfoObject.title</h3>

<p>控制台标题</p>

<p><a id="startinfoObject.username"></a></p>

<h3>startinfoObject.username</h3>

<p>登录用户名</p>

<p><a id="startinfoObject.waitInputTimeout"></a></p>

<h3>startinfoObject.waitInputTimeout</h3>

<p>进程启动后等待初始化完成的最大超时<br>
默认为0xFFFFFFFF(无限等待),设为0则不等待</p>

<p><a id="startinfoObject.workDir"></a></p>

<h3>startinfoObject.workDir</h3>

<p>进程工作目录,<br>
默认值为 process.workDir</p>

<p><a id="startinfoObject.x"></a></p>

<h3>startinfoObject.x</h3>

<p>x坐标(子进程使用默认坐标时、或控制台窗口支持)</p>

<p><a id="startinfoObject.xCountChars"></a></p>

<h3>startinfoObject.xCountChars</h3>

<p>控制台宽度(字符单位)</p>

<p><a id="startinfoObject.xSize"></a></p>

<h3>startinfoObject.xSize</h3>

<p>窗口宽(子进程使用默认坐标时、或控制台窗口支持)</p>

<p><a id="startinfoObject.y"></a></p>

<h3>startinfoObject.y</h3>

<p>y坐标(子进程使用默认坐标时、或控制台窗口支持)</p>

<p><a id="startinfoObject.yCountChars"></a></p>

<h3>startinfoObject.yCountChars</h3>

<p>控制台高度(字符单位)</p>

<p><a id="startinfoObject.ySize"></a></p>

<h3>startinfoObject.ySize</h3>

<p>窗口高(子进程使用默认坐标时、或控制台窗口支持)</p>

<p><a id="threadEntry"></a></p>

<h2>threadEntry 成员列表</h2>

<p><a id="threadEntry.cntUsage"></a></p>

<h3>threadEntry.cntUsage</h3>

<p>引用计数</p>

<p><a id="threadEntry.dwFlags"></a></p>

<h3>threadEntry.dwFlags</h3>

<p>th32OwnerProcessID = 进程ID</p>

<p><a id="threadEntry.dwSize"></a></p>

<h3>threadEntry.dwSize</h3>

<p>结构体大小</p>

<p><a id="threadEntry.th32OwnerProcessID"></a></p>

<h3>threadEntry.th32OwnerProcessID</h3>

<pre><code class="aardio language-aardio">Process this thread is associated with
</code></pre>

<p><a id="threadEntry.th32ThreadID"></a></p>

<h3>threadEntry.th32ThreadID</h3>

<p>线程ID</p>

<p><a id="threadEntry.tpBasePri"></a></p>

<h3>threadEntry.tpBasePri</h3>

<pre><code class="aardio language-aardio">tpDeltaPri =
</code></pre>

<h3>自动完成常量</h3>

<p>_CREATE_NEW_CONSOLE=0x10<br>
_CREATE_NEW_PROCESS_GROUP=0x200<br>
_CREATE_NO_WINDOW=0x8000000<br>
_CREATE_PROCESS_DEBUG_EVENT=3<br>
_CREATE_SUSPENDED=4<br>
_MEM_4MB_PAGES=0x80000000<br>
_MEM_COMMIT=0x1000<br>
_MEM_DECOMMIT=0x4000<br>
_MEM_FREE=0x10000<br>
_MEM_LARGE_PAGES=0x20000000<br>
_MEM_MAPPED=0x40000<br>
_MEM_PHYSICAL=0x400000<br>
_MEM_PRIVATE=0x20000<br>
_MEM_RELEASE=0x8000<br>
_MEM_RESERVE=0x2000<br>
_MEM_RESET=0x80000<br>
_MEM_ROTATE=0x800000<br>
_MEM_TOP_DOWN=0x100000<br>
_MEM_WRITE_WATCH=0x200000<br>
_PAGE_EXECUTE=0x10<br>
_PAGE_EXECUTE_READ=0x20<br>
_PAGE_EXECUTE_READWRITE=0x40<br>
_PAGE_EXECUTE_WRITECOPY=0x80<br>
_PAGE_GUARD=0x100<br>
_PAGE_NOACCESS=1<br>
_PAGE_NOCACHE=0x200<br>
_PAGE_READONLY=2<br>
_PAGE_READWRITE=4<br>
_PAGE_WRITECOMBINE=0x400<br>
_PAGE_WRITECOPY=8<br>
_PROCESS_ALL_ACCESS=0x1FFFFF<br>
_PROCESS_CREATE_PROCESS=0x80<br>
_PROCESS_CREATE_THREAD=2<br>
_PROCESS_DUP_HANDLE=0x40<br>
_PROCESS_QUERY_INFORMATION=0x400<br>
_PROCESS_QUERY_LIMITED_INFORMATION=0x1000<br>
_PROCESS_SET_INFORMATION=0x200<br>
_PROCESS_SET_QUOTA=0x100<br>
_PROCESS_SET_SESSIONID=4<br>
_PROCESS_SUSPEND_RESUME=0x800<br>
_PROCESS_TERMINATE=1<br>
_PROCESS_VM_OPERATION=8<br>
_PROCESS_VM_READ=0x10<br>
_PROCESS_VM_WRITE=0x20<br>
_STANDARD_RIGHTS_REQUIRED=0xF0000<br>
_SYNCHRONIZE=0x100000<br>
_TH32CS_INHERIT=0x80000000<br>
_TH32CS_SNAPALL=0xF<br>
_TH32CS_SNAPHEAPLIST=1<br>
_TH32CS_SNAPMODULE=8<br>
_TH32CS_SNAPMODULE32=0x10<br>
_TH32CS_SNAPPROCESS=2<br>
_TH32CS_SNAPTHREAD=4  </p>

<p><a href="_.md" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/process/_.md">Markdown 格式</a></p>

</body> 
</html>