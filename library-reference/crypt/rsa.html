
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - crypt.rsa 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - crypt.rsa 库模块帮助文档</title> 
<link rel="stylesheet" href="../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>crypt.rsa 库模块帮助文档</h1>

<p><a id="crypt"></a></p>

<h2>crypt 成员列表</h2>

<p><a id="crypt.rsa"></a></p>

<h3>crypt.rsa</h3>

<p>RSA加密算法支持库</p>

<p><a id="crypt.rsa"></a></p>

<h3>crypt.rsa()</h3>

<p>创建RSA加密容器,不建议指定参数,  </p>

<p><a href="#cryptrsaObject">返回对象:cryptrsaObject</a></p>

<p><a id="cryptrsaObject"></a></p>

<h2>cryptrsaObject 成员列表</h2>

<p><a id="cryptrsaObject.allocBuffer"></a></p>

<h3>cryptrsaObject.allocBuffer</h3>

<p>分配加解密需要用到的 buffer。</p>

<p><a id="cryptrsaObject.allocBuffer"></a></p>

<h3>cryptrsaObject.allocBuffer(大小,块大小)</h3>

<p>分配加解密需要用到的 buffer。<br>
如果不手动分配，程序将会自动按需分配 buffer。<br>
参数 @2 可选，可用对象的blockSize属性指定默认块大小。</p>

<p><a id="cryptrsaObject.blockSize"></a></p>

<h3>cryptrsaObject.blockSize</h3>

<p>加密填充的块大小</p>

<p><a id="cryptrsaObject.createHash"></a></p>

<h3>cryptrsaObject.createHash()</h3>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashByHmac"></a></p>

<h3>cryptrsaObject.createHashByHmac()</h3>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashByHmac"></a></p>

<h3>cryptrsaObject.createHashByHmac(哈希数据,哈希算法)</h3>

<p>所有参数可选,<br>
哈希算法默认为_CALG_SHA1</p>

<p><a id="cryptrsaObject.createHashByKey"></a></p>

<h3>cryptrsaObject.createHashByKey()</h3>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashByKey"></a></p>

<h3>cryptrsaObject.createHashByKey(算法ID)</h3>

<p>使用当前密钥创建哈希</p>

<p><a id="cryptrsaObject.createHashByMd2"></a></p>

<h3>cryptrsaObject.createHashByMd2()</h3>

<p>创建MD2算法哈希对象<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashByMd4"></a></p>

<h3>cryptrsaObject.createHashByMd4()</h3>

<p>创建MD4算法哈希对象<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashByMd5"></a></p>

<h3>cryptrsaObject.createHashByMd5()</h3>

<p>创建MD5算法哈希对象<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashBySha1"></a></p>

<h3>cryptrsaObject.createHashBySha1()</h3>

<p>创建Sha1算法哈希对象<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashBySha256"></a></p>

<h3>cryptrsaObject.createHashBySha256()</h3>

<p>创建 Sha256 算法哈希对象,<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashBySha384"></a></p>

<h3>cryptrsaObject.createHashBySha384()</h3>

<p>创建 Sha384 算法哈希对象,<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.createHashBySha512"></a></p>

<h3>cryptrsaObject.createHashBySha512()</h3>

<p>创建 Sha512 算法哈希对象,<br>
可选使用一个字符串参数指定哈希数据  </p>

<p><a href="#cryptHashObject">返回对象:cryptHashObject</a></p>

<p><a id="cryptrsaObject.decodeObject"></a></p>

<h3>cryptrsaObject.decodeObject(encoded,encodingType,structType)</h3>

<p>解码对象,<br>
参数@1为buffer或字符串,返回值为buffer类型,<br>
用法参考 crypt.rsa中相关函数</p>

<p><a id="cryptrsaObject.decrypt"></a></p>

<h3>cryptrsaObject.decrypt</h3>

<p>RSA解密。解密模式为 RSA/ECB/PKCS1Padding。<br>
与其他解密结果字节序相反的编程语言互通可改用 decryptReverse 函数。</p>

<p><a id="cryptrsaObject.decrypt"></a></p>

<h3>cryptrsaObject.decrypt(输入数据,是否已输入全部数据,哈希对象,选项)</h3>

<p>参数 @1 指定字符串或 buffer。<br>
除第一个参数以外，其他参数都是可选参数。<br>
分块解密时，参数 @2 必须为 flase 且参数 @1 的长度必须是块大小的倍数。<br>
成功返回解密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.decrypt"></a></p>

<h3>cryptrsaObject.decrypt(输入缓冲区,输入数据大小,哈希对象,选项)</h3>

<p>参数 @1 指定 buffer 或字符串。<br>
如果参数 @2 指定的数值小于缓冲区据总长度，解密结束。<br>
可使用 -1 表示解密结束，且输入数据大小等于缓冲区大小。<br>
其他参数可忽略不用管。  </p>

<p>成功返回存放解密结果的字符串，返回值 2 为返回字符串的长度。<br>
失败返回 null, 错误信息,错误代码。</p>

<p><a id="cryptrsaObject.decryptFile"></a></p>

<h3>cryptrsaObject.decryptFile</h3>

<p>解密文件</p>

<p>解密文件</p>

<p><a id="cryptrsaObject.decryptFile"></a></p>

<h3>cryptrsaObject.decryptFile(加密源文件路径,输出文件路径,缓冲区大小,哈希对象,选项)</h3>

<p>参数 @1 指定要解密的文件路径。<br>
参数 @2 指定要保存解密结果的文件路径。<br>
可选用参数 @3 指定分块加密的字节长度，默认为 1MB。<br>
指定字节长度时会自动调整到对齐块大小，参数不需要考虑对齐。<br>
其他参数一般不必指定。</p>

<p><a id="cryptrsaObject.decryptFile"></a></p>

<h3>cryptrsaObject.decryptFile(输入文件,输出文件,缓冲区大小,进度回调函数,哈希对象,选项)</h3>

<p>参数 @1 指定要解密的文件。参数 @2 指定要保存解密结果的文件。<br>
文件参数都可以指定文件路径、文件对象（兼容 io.file,fsys.file,fsys.stream）。<br>
可选用参数 @3 指定分块加密的字节长度，默认为 1MB。<br>
指定字节长度时会自动调整到对齐块大小，参数不需要考虑对齐。<br>
可选指定进度回调函数，回调参数 @1,@2 分别为输入文件总长度、已读取长度。<br>
其他调用参数（哈希对象，选项）一般不必指定。  </p>

<p>函数执行成功返回 true，失败返回 null,错误信息。</p>

<p><a id="cryptrsaObject.decryptOaep"></a></p>

<h3>cryptrsaObject.decryptOaep(字符串,是否已输入全部数据,哈希对象)</h3>

<p>RSA 解密。<br>
填充模式为 PKCS#1 OAEP，其他与 decrypt 函数相同。<br>
除第一个参数以外,其他参数都是可选参数<br>
成功返回解密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.decryptOaepReverse"></a></p>

<h3>cryptrsaObject.decryptOaepReverse(字符串)</h3>

<p>RSA 解密，反转字节序。<br>
填充模式为 PKCS#1 OAEP，其他与 decryptReverse 函数相同。<br>
成功返回解密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.decryptReverse"></a></p>

<h3>cryptrsaObject.decryptReverse</h3>

<p>RSA解密，反转字节序,<br>
解密模式为 RSA/ECB/PKCS1Padding</p>

<p><a id="cryptrsaObject.decryptReverse"></a></p>

<h3>cryptrsaObject.decryptReverse(字符串,选项)</h3>

<p>选项为可选参数<br>
成功返回解密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.decryptToArray"></a></p>

<h3>cryptrsaObject.decryptToArray</h3>

<p>RSA解密,并返回字符串数组,<br>
解密模式为 RSA/ECB/PKCS1Padding<br>
与C#、Java等互通建议改用decryptReverse</p>

<p><a id="cryptrsaObject.decryptToArray"></a></p>

<h3>cryptrsaObject.decryptToArray(字符串,是否已输入全部数据,哈希对象,选项)</h3>

<p>除第一个参数以外,其他参数都是可选参数<br>
成功返回解密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.duplicateKey"></a></p>

<h3>cryptrsaObject.duplicateKey()</h3>

<p>获取并复制当前使用的密钥,<br>
该密钥必须调用 destroy 成员函数手动销毁  </p>

<p><a href="#cryptKeyObject">返回对象:cryptKeyObject</a></p>

<p><a id="cryptrsaObject.encodeObject"></a></p>

<h3>cryptrsaObject.encodeObject(structInfo,encodingType,structType)</h3>

<p>编码对象,<br>
参数@1为buffer或字符串,返回值为buffer类型,<br>
用法参考 crypt.rsa中相关函数</p>

<p><a id="cryptrsaObject.encrypt"></a></p>

<h3>cryptrsaObject.encrypt</h3>

<p>加密数据</p>

<p>RSA加密<br>
加密模式为 RSA/ECB/PKCS1Padding<br>
与与其他有k密结果字节序相反的编程语言互通可改用 encryptReverse 函数。</p>

<p><a id="cryptrsaObject.encrypt"></a></p>

<h3>cryptrsaObject.encrypt(输入数据,是否已输入全部数据,哈希对象,选项)</h3>

<p>参数 @1 指定字符串或 buffer。<br>
除第一个参数以外，其他参数都是可选参数。<br>
分块加密时，参数 @2 必须为 flase 且参数 @1 的长度必须是块大小的倍数。<br>
成功返回加密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.encrypt"></a></p>

<h3>cryptrsaObject.encrypt(输入缓冲区,输入数据大小,哈希对象,选项)</h3>

<p>参数 @1 指定 buffer 或字符串。<br>
如果参数 @2 指定的数值小于缓冲区据总长度，加密结束。<br>
可使用 -1 表示解密结束，且输入数据大小等于缓冲区大小。<br>
其他参数可忽略不用管。  </p>

<p>成功返回存放加密结果的字符串，返回值 2 为返回字符串的长度。<br>
失败返回 null, 错误信息,错误代码。</p>

<p><a id="cryptrsaObject.encryptFile"></a></p>

<h3>cryptrsaObject.encryptFile</h3>

<p>加密文件</p>

<p>加密文件</p>

<p><a id="cryptrsaObject.encryptFile"></a></p>

<h3>cryptrsaObject.encryptFile(加密源文件路径,输出文件路径,缓冲区大小,哈希对象,选项)</h3>

<p>参数 @1 指定要加密的文件路径。<br>
参数 @2 指定要保存加密结果的文件路径。<br>
可选用参数 @3 指定分块加密的字节长度，默认为 1MB。<br>
指定字节长度时会自动调整到对齐块大小，参数不需要考虑对齐<br>
其他参数一般不必指定。</p>

<p><a id="cryptrsaObject.encryptFile"></a></p>

<h3>cryptrsaObject.encryptFile(输入文件,输出文件,缓冲区大小,进度回调函数,哈希对象,选项)</h3>

<p>参数 @1 指定要加密的文件。参数 @2 指定要保存加密结果的文件。<br>
文件参数都可以指定文件路径、文件对象（兼容 io.file,fsys.file,fsys.stream）。<br>
可选用参数 @3 指定分块加密的字节长度，默认为 1MB。<br>
指定字节长度时会自动调整到对齐块大小，参数不需要考虑对齐。<br>
可选指定进度回调函数，回调参数 @1,@2 分别为输入文件总长度、已读取长度。<br>
其他调用参数（哈希对象，选项）一般不必指定。  </p>

<p>函数执行成功返回 true，失败返回 null,错误信息。</p>

<p><a id="cryptrsaObject.encryptOaep"></a></p>

<h3>cryptrsaObject.encryptOaep(字符串,是否已输入全部数据,哈希对象,选项)</h3>

<p>RSA 加密。<br>
填充模式为 PKCS#1 OAEP，其他与 encrypt 函数相同。<br>
除第一个参数以外,其他参数都是可选参数<br>
成功返回加密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.encryptOaepReverse"></a></p>

<h3>cryptrsaObject.encryptOaepReverse(字符串)</h3>

<p>RSA加密，反转字节序。<br>
填充模式为 PKCS#1 OAEP，其他与 encryptReverse 函数相同。<br>
成功返回加密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.encryptReverse"></a></p>

<h3>cryptrsaObject.encryptReverse</h3>

<p>RSA加密，反转字节序,<br>
加密模式为 RSA/ECB/PKCS1Padding</p>

<p><a id="cryptrsaObject.encryptReverse"></a></p>

<h3>cryptrsaObject.encryptReverse(字符串,选项)</h3>

<p>选项为可选可选参数<br>
成功返回加密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.encryptToArray"></a></p>

<h3>cryptrsaObject.encryptToArray</h3>

<p>RSA加密,并返回字符串数组,<br>
加密模式为 RSA/ECB/PKCS1Padding<br>
与C#、Java等互通建议改用encryptReverse</p>

<p><a id="cryptrsaObject.encryptToArray"></a></p>

<h3>cryptrsaObject.encryptToArray(字符串,是否已输入全部数据,哈希对象,选项)</h3>

<p>除第一个参数以外,其他参数都是可选参数<br>
成功返回加密文本,失败返回空,<br>
可使用..lasterr()函数获取错误信息</p>

<p><a id="cryptrsaObject.exportKey"></a></p>

<h3>cryptrsaObject.exportKey(导出密钥类型,选项,加密密钥句柄)</h3>

<p>导出密钥,除参数一以外其他参数可选<br>
参数1为密钥类型,参数三为导出密钥可为空</p>

<p><a id="cryptrsaObject.exportPkcs8"></a></p>

<h3>cryptrsaObject.exportPkcs8(keySpec,objId)</h3>

<p>导出PKCS#8格式私钥,返回值为buffer类型,<br>
用法参考 crypt.rsa中相关函数</p>

<p><a id="cryptrsaObject.exportPlainTextKey"></a></p>

<h3>cryptrsaObject.exportPlainTextKey(选项,加密密钥句柄)</h3>

<p>导出文本密钥,参数可选</p>

<p><a id="cryptrsaObject.exportPrivateKey"></a></p>

<h3>cryptrsaObject.exportPrivateKey(选项,加密密钥句柄)</h3>

<p>导出私钥,参数可选</p>

<p><a id="cryptrsaObject.exportPrivateKeyPkcs1Raw"></a></p>

<h3>cryptrsaObject.exportPrivateKeyPkcs1Raw()</h3>

<p>导出 PKCS#1 格式私钥,<br>
返回值为buffer类型</p>

<p><a id="cryptrsaObject.exportPrivateKeyPkcs1RawToPem"></a></p>

<h3>cryptrsaObject.exportPrivateKeyPkcs1RawToPem()</h3>

<p>导出 PKCS#1 格式私钥（PEM）,<br>
返回值为string类型</p>

<p><a id="cryptrsaObject.exportPrivateKeyPkcs8"></a></p>

<h3>cryptrsaObject.exportPrivateKeyPkcs8()</h3>

<p>导出通用的 PKCS#8 格式私钥,<br>
可选用参数@1指定密钥类型为 _AT_SIGNATURE 或 _AT_KEYEXCHANGE,<br>
建议不指定参数自动获取默认设置</p>

<p><a id="cryptrsaObject.exportPrivateKeyPkcs8ToPem"></a></p>

<h3>cryptrsaObject.exportPrivateKeyPkcs8ToPem()</h3>

<p>导出通用的 PKCS#8 格式私钥（PEM）,<br>
可选用参数@1指定密钥类型为 _AT_SIGNATURE 或 _AT_KEYEXCHANGE,<br>
建议不指定参数自动获取默认设置</p>

<p><a id="cryptrsaObject.exportPublicKey"></a></p>

<h3>cryptrsaObject.exportPublicKey(选项,加密密钥句柄)</h3>

<p>导出公钥,参数可选</p>

<p><a id="cryptrsaObject.exportPublicKeyInfo"></a></p>

<h3>cryptrsaObject.exportPublicKeyInfo(keySpec,encodingType)</h3>

<p>导出公钥信息(CERT_PUBLIC_KEY_INFO),返回值为buffer类型,<br>
用法参考 crypt.rsa中相关函数</p>

<p><a id="cryptrsaObject.exportPublicKeyPkcs1Raw"></a></p>

<h3>cryptrsaObject.exportPublicKeyPkcs1Raw()</h3>

<p>导出 PKCS#1 格式公钥,<br>
返回值为buffer类型</p>

<p><a id="cryptrsaObject.exportPublicKeyPkcs1RawToPem"></a></p>

<h3>cryptrsaObject.exportPublicKeyPkcs1RawToPem()</h3>

<p>导出 PKCS#1 格式公钥（PEM）,<br>
返回值为string类型</p>

<p><a id="cryptrsaObject.exportPublicKeyX509"></a></p>

<h3>cryptrsaObject.exportPublicKeyX509()</h3>

<p>导出通用的 SPKI（Subject Public Key Info）格式公钥,<br>
可选用参数@1指定密钥类型为 _AT_SIGNATURE 或 _AT_KEYEXCHANGE,<br>
建议不指定参数自动获取默认设置,<br>
返回值为buffer类型</p>

<p><a id="cryptrsaObject.exportPublicKeyX509ToPem"></a></p>

<h3>cryptrsaObject.exportPublicKeyX509ToPem()</h3>

<p>导出通用的 SPKI（Subject Public Key Info）格式公钥（PEM）,<br>
可选用参数@1指定密钥类型为 _AT_SIGNATURE 或 _AT_KEYEXCHANGE,<br>
建议不指定参数自动获取默认设置,<br>
返回值为string类型</p>

<p><a id="cryptrsaObject.genKey"></a></p>

<h3>cryptrsaObject.genKey(algid,flags,size)</h3>

<p>产生一个随机的会话密钥或者公/私钥对,<br>
所有参数可选,algid指定算法,flags指定选项,size指定密钥长度</p>

<p><a id="cryptrsaObject.genSignatureKey"></a></p>

<h3>cryptrsaObject.genSignatureKey(size,flags)</h3>

<p>创建用于签名算法的公/私钥对,<br>
@size 指定密钥长度,以二进制位为单位,省略此参数则默认为 2048,<br>
@flags 指定选项,一般不必指定</p>

<p><a id="cryptrsaObject.getKeyAlgId"></a></p>

<h3>cryptrsaObject.getKeyAlgId()</h3>

<p>返回当前密钥算法 ID</p>

<p><a id="cryptrsaObject.getKeyBlockLen"></a></p>

<h3>cryptrsaObject.getKeyBlockLen()</h3>

<p>获取密钥块长度</p>

<p><a id="cryptrsaObject.getKeyParam"></a></p>

<h3>cryptrsaObject.getKeyParam(类型,数据值)</h3>

<p>获取密钥参数<br>
数据值应当指定一个结构体<br>
不指定数据值则自动分配buffer对象存储返回值<br>
失败返回null</p>

<p><a id="cryptrsaObject.getKeyParamNumber"></a></p>

<h3>cryptrsaObject.getKeyParamNumber(类型)</h3>

<p>获取数值类型密钥参数</p>

<p><a id="cryptrsaObject.getKeySpec"></a></p>

<h3>cryptrsaObject.getKeySpec()</h3>

<p>返回当前密钥类型,<br>
返回值为 _AT_SIGNATURE 或 _AT_KEYEXCHANGE</p>

<p><a id="cryptrsaObject.getUserKey"></a></p>

<h3>cryptrsaObject.getUserKey(keySpec)</h3>

<p>获取密钥,并设置为默认密钥<br>
参数指定密钥类型，例如 _AT_SIGNATURE<br>
成功返回true</p>

<p><a id="cryptrsaObject.hasKey"></a></p>

<h3>cryptrsaObject.hasKey()</h3>

<p>检测是否已设置密钥</p>

<p><a id="cryptrsaObject.hash"></a></p>

<h3>cryptrsaObject.hash(字符串,是否大写,返回16位结果,算法)</h3>

<p>计算哈希值,<br>
除第一个参数以外,其他参数可选<br>
默认使用MD5算法</p>

<p><a id="cryptrsaObject.hashFile"></a></p>

<h3>cryptrsaObject.hashFile(文件路径,是否大写,算法)</h3>

<p>计算哈希值,<br>
除第一个参数以外,其他参数可选<br>
默认使用MD5算法</p>

<p><a id="cryptrsaObject.importKey"></a></p>

<h3>cryptrsaObject.importKey(密钥,选项,公钥句柄)</h3>

<p>导入密钥,<br>
密钥可以是结构体或字符串格式,<br>
参数2可选,参数3可选<br>
成功返回true,失败返回null,错误信息</p>

<p><a id="cryptrsaObject.importPemKey"></a></p>

<h3>cryptrsaObject.importPemKey()</h3>

<p>参数 @1 使用字符串指定 PEM 格式密钥。<br>
如果导入成功返回 PEM 格式头</p>

<p><a id="cryptrsaObject.importPemKeyFile"></a></p>

<h3>cryptrsaObject.importPemKeyFile()</h3>

<p>参数 @1 使用字符串指定 PEM 格式密钥文件。<br>
如果导入成功返回 PEM 格式头</p>

<p><a id="cryptrsaObject.importPrivateKeyInfo"></a></p>

<h3>cryptrsaObject.importPrivateKeyInfo(certPrivateKeyInfo,encodingType,structType)</h3>

<p>导入私钥信息(CRYPT_PRIVATE_KEY_INFO),参数@1为buffer或字符串,<br>
用法参考 crypt.rsa中相关函数,<br>
成功返回true</p>

<p><a id="cryptrsaObject.importPrivateKeyPkcs1Raw"></a></p>

<h3>cryptrsaObject.importPrivateKeyPkcs1Raw()</h3>

<p>导入 PKCS#1 格式私钥,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPrivateKeyPkcs1RawFromPem"></a></p>

<h3>cryptrsaObject.importPrivateKeyPkcs1RawFromPem()</h3>

<p>导入 PKCS#1 格式私钥（PEM）,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPrivateKeyPkcs8"></a></p>

<h3>cryptrsaObject.importPrivateKeyPkcs8()</h3>

<p>导入通用的 PKCS#8 格式私钥,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPrivateKeyPkcs8FromPem"></a></p>

<h3>cryptrsaObject.importPrivateKeyPkcs8FromPem()</h3>

<p>导入通用的 PKCS#8 格式私钥（PEM）,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPublicKeyInfo"></a></p>

<h3>cryptrsaObject.importPublicKeyInfo(certPublicKeyiNFO,encodingType)</h3>

<p>导入公钥信息(CERT_PUBLIC_KEY_INFO),参数@1为buffer或字符串,<br>
用法参考 crypt.rsa中相关函数,<br>
成功返回true</p>

<p><a id="cryptrsaObject.importPublicKeyPkcs1Raw"></a></p>

<h3>cryptrsaObject.importPublicKeyPkcs1Raw()</h3>

<p>导入 PKCS#1 格式公钥,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPublicKeyPkcs1RawFromPem"></a></p>

<h3>cryptrsaObject.importPublicKeyPkcs1RawFromPem()</h3>

<p>导入 PKCS#1 格式公钥（PEM）,<br>
参数@1为string或buffer类型私钥</p>

<p><a id="cryptrsaObject.importPublicKeyX509"></a></p>

<h3>cryptrsaObject.importPublicKeyX509()</h3>

<p>导入通用的 SPKI（Subject Public Key Info）格式公钥,<br>
参数@1为string或buffer类型公钥数据</p>

<p><a id="cryptrsaObject.importPublicKeyX509FromPem"></a></p>

<h3>cryptrsaObject.importPublicKeyX509FromPem()</h3>

<p>导入通用的 SPKI（Subject Public Key Info）格式公钥（PEM）,<br>
参数@1为string或buffer类型公钥数据</p>

<p><a id="cryptrsaObject.lastHash"></a></p>

<h3>cryptrsaObject.lastHash</h3>

<p>最后一次调用createHashXXX() 系列函数创建的哈希对象</p>

<p><a id="cryptrsaObject.release"></a></p>

<h3>cryptrsaObject.release()</h3>

<p>释放密码服务对象(CSP)<br>
此函数可在对象析构时自动调用</p>

<p><a id="cryptrsaObject.setInitVector"></a></p>

<h3>cryptrsaObject.setInitVector(字符串向量,选项)</h3>

<p>设置初始化向量,成功返回true,<br>
参数2可选</p>

<p><a id="cryptrsaObject.setKey"></a></p>

<h3>cryptrsaObject.setKey(密钥句柄)</h3>

<p>设置新的默认密钥句柄,<br>
该密钥将由密钥容器管理,不需要释放该密钥<br>
参数为null则删除密钥</p>

<p><a id="cryptrsaObject.setKeyParam"></a></p>

<h3>cryptrsaObject.setKeyParam(类型,数据值,选项)</h3>

<p>设置加密参数<br>
数据值可以是结构体,字符串，或 buffer 对象,<br>
如果数据值一个数值参数,则转换为表示32位整型数值地址的结构体指针<br>
成功返回true,失败请使用 ..lasterr()获取错误信息</p>

<p><a id="cryptrsaObject.setKeyParamMode"></a></p>

<h3>cryptrsaObject.setKeyParamMode(_CRYPT_MODE)</h3>

<p>设置加密模式<br>
成功返回true,失败请使用 ..lasterr()获取错误信息</p>

<p><a id="cryptrsaObject.setKeyParamPadding"></a></p>

<h3>cryptrsaObject.setKeyParamPadding(_PKCS5)</h3>

<p>设置加密填充方式<br>
成功返回true,失败请使用 ..lasterr()获取错误信息</p>

<p><a id="cryptrsaObject.setPassword"></a></p>

<h3>cryptrsaObject.setPassword(&quot;字符串参数&quot;,HASH算法ID,加密算法ID,选项)</h3>

<p>设置会话密钥<br>
成功返回密码容器对象,失败返回null</p>

<p><a id="cryptrsaObject.sign"></a></p>

<h3>cryptrsaObject.sign(keySpec,flags)</h3>

<p>返回签名<br>
可选用 @keySpec 参数中指定密钥类型,<br>
@flags 不必指定</p>

<p><a id="cryptrsaObject.signToBase64"></a></p>

<h3>cryptrsaObject.signToBase64(keySpec,flags)</h3>

<p>签名并反转字节序,进行 Base64 编码后返回,<br>
可选用 @keySpec 参数中指定密钥类型,<br>
@flags 参数不必指定</p>

<p><a id="cryptrsaObject.verifyFromBase64"></a></p>

<h3>cryptrsaObject.verifyFromBase64(signBase64,flags)</h3>

<p>验证签名,<br>
参数@signBase64 为 Base64编码并反转字节序的签名,<br>
@flags 参数不必指定,<br>
验证签名以前必须首先导入公钥,并创建哈希对象</p>

<p><a id="cryptrsaObject.verifySignature"></a></p>

<h3>cryptrsaObject.verifySignature(sign,flags)</h3>

<p>验证签名,<br>
参数@1为签名字符串,其他参数可选<br>
验证签名以前必须首先导入公钥,并创建哈希</p>

<p><a href="rsa.md" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/crypt/rsa.md">Markdown 格式</a></p>

</body> 
</html>