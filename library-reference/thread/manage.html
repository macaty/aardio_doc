
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - thread.manage 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - thread.manage 库模块帮助文档</title> 
<link rel="stylesheet" href="../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>thread.manage 库模块帮助文档</h1>

<p><a id="thread"></a></p>

<h2>thread 成员列表</h2>

<p><a id="thread.manage"></a></p>

<h3>thread.manage</h3>

<p>线程管理器</p>

<p><a id="thread.manage"></a></p>

<h3>thread.manage()</h3>

<p>创建线程管理器。<br>
可使用一个参数指定线程池大小，<br>
默认为 63,该值必须小于 64  </p>

<p><a href="#threadMgrObject">返回对象:threadMgrObject</a></p>

<p><a id="ThreadMgrCbLiteObject"></a></p>

<h2>ThreadMgrCbLiteObject 成员列表</h2>

<p><a id="ThreadMgrCbLiteObject.onEnd"></a></p>

<h3>ThreadMgrCbLiteObject.onEnd</h3>

<pre><code class="aardio language-aardio">ThreadMgrCbLiteObject.onEnd = function(){
    /*线程结束回调此函数，无参数。  
必须调用 thread.manage 对象的 waitOne 或 waitClose 函数  
才会触发 onEnd 回调函数*/   
}
</code></pre>

<p><a id="ThreadMgrCbObject"></a></p>

<h2>ThreadMgrCbObject 成员列表</h2>

<p><a id="ThreadMgrCbObject.onEnd"></a></p>

<h3>ThreadMgrCbObject.onEnd</h3>

<pre><code class="aardio language-aardio">ThreadMgrCbObject.onEnd = function(...){
    /*线程结束回调此函数，参数为线程执行函数返回的值。  
必须调用 thread.manage 对象的 waitOne 或 waitClose 函数  
才会触发 onEnd 回调函数*/   
}
</code></pre>

<p><a id="threadMgrObject"></a></p>

<h2>threadMgrObject 成员列表</h2>

<p><a id="threadMgrObject.busy"></a></p>

<h3>threadMgrObject.busy()</h3>

<p>如果线程池里仍有未关闭的线程句柄返回 false，否则返回 true 。<br>
必须调用 waitOne 或 waitClose 函数才会自动关闭已结束的线程句柄</p>

<p><a id="threadMgrObject.create"></a></p>

<h3>threadMgrObject.create</h3>

<p>创建线程，<br>
如果线程池已满会自动等待其他线程结束，并自动关闭已结束的线程句柄</p>

<p><a id="threadMgrObject.create"></a></p>

<h3>threadMgrObject.create()</h3>

<p><a href="#ThreadMgrCbObject">返回对象:ThreadMgrCbObject</a></p>

<p><a id="threadMgrObject.create"></a></p>

<h3>threadMgrObject.create(线程执行函数,任意个启动参数)</h3>

<p>创建线程。<br>
此函数参数与 thread.create 函数的参数一致。  </p>

<p>返回对象可指定 onEnd 成员函数，<br>
线程结束将线程函数返回值作为参数回调 onEnd 函数。<br>
必须调用 thread.manage 对象的 waitClose 函数<br>
才会触发 onEnd 回调函数</p>

<p><a id="threadMgrObject.createLite"></a></p>

<h3>threadMgrObject.createLite</h3>

<p>创建线程，但忽略线程执行函数的返回值。<br>
如果线程池已满会自动等待其他线程结束，并自动关闭已结束的线程句柄</p>

<p><a id="threadMgrObject.createLite"></a></p>

<h3>threadMgrObject.createLite()</h3>

<p><a href="#ThreadMgrCbLiteObject">返回对象:ThreadMgrCbLiteObject</a></p>

<p><a id="threadMgrObject.createLite"></a></p>

<h3>threadMgrObject.createLite(线程执行函数,任意个启动参数)</h3>

<p>创建线程但忽略线程执行函数的返回值。<br>
此函数参数与 thread.create 函数的参数一致。  </p>

<p>返回对象可指定 onEnd 成员函数，<br>
线程函数结束将回调 onEnd 函数，回调函数无参数。<br>
必须调用 thread.manage 对象的 waitClose 函数<br>
才会触发 onEnd 回调函数</p>

<p><a id="threadMgrObject.createSuspended"></a></p>

<h3>threadMgrObject.createSuspended()</h3>

<p>创建线程并且暂停执行<br>
如果线程池已满会自动等待其他线程结束，并自动关闭已结束的线程句柄</p>

<p><a href="#ThreadMgrCbObject">返回对象:ThreadMgrCbObject</a></p>

<p><a id="threadMgrObject.createSuspended"></a></p>

<h3>threadMgrObject.createSuspended(线程执行函数,任意个启动参数)</h3>

<p>创建线程并且暂停执行。<br>
此函数参数与 thread.create 函数的参数一致。  </p>

<p>返回对象可指定 onEnd 成员函数，<br>
线程结束将线程函数返回值作为参数回调 onEnd 函数。<br>
必须调用 thread.manage 对象的 waitClose 函数<br>
才会触发 onEnd 回调函数</p>

<p><a id="threadMgrObject.quitMessage"></a></p>

<h3>threadMgrObject.quitMessage()</h3>

<p>向所有线程发送 _WM_QUIT 消息<br>
线程内 win.delay 函数可接受该消息并返回 false 值</p>

<p><a id="threadMgrObject.resume"></a></p>

<h3>threadMgrObject.resume()</h3>

<p>所有线程继续执行</p>

<p><a id="threadMgrObject.suspend"></a></p>

<h3>threadMgrObject.suspend()</h3>

<p>所有线程暂停。<br>
注意线程是否正在使用互斥锁</p>

<p><a id="threadMgrObject.waitClose"></a></p>

<h3>threadMgrObject.waitClose()</h3>

<p>等待所有线程返回，不阻塞界面线程消息处理。<br>
并关闭所有线程句柄。  </p>

<p>添加线程以后，必须调用 waitClose 函数</p>

<p><a id="threadMgrObject.waitOne"></a></p>

<h3>threadMgrObject.waitOne()</h3>

<p>等待任一线程返回，不阻塞界面线程消息处理。<br>
并关闭已结束的线程句柄。<br>
失败返回 null  </p>

<p>waitClose 函数实际上循环调用 waitOne 函数。</p>

<p><a href="manage.md" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/thread/manage.md">Markdown 格式</a></p>

</body> 
</html>