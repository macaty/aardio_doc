
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="robots" content="index, follow">
<meta name='description' content='aardio 编程语言文档 - thread.table 库模块帮助文档'>
<meta http-equiv='content-language' content='zh-cn'>
<title>aardio 编程语言文档 - thread.table 库模块帮助文档</title> 
<link rel="stylesheet" href="../../css/markdown.css" tppabs="https://www.aardio.com/zh-cn/doc/css/markdown.css">
<script src="../../js/prism.js" tppabs="https://www.aardio.com/zh-cn/doc/js/prism.js"></script>
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/fontawesome.min.css">
<link rel="stylesheet" href="../../../../../lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css" tppabs="https://lib.baomitu.com/font-awesome/6.6.0/css/solid.min.css">
</head>
<body class="markdown-body"><a id="back-to-home" href="../../index.htm" tppabs="https://www.aardio.com/zh-cn/doc/" title="aardio 编程语言文档首页"><i class="fas fa-home" id="home-icon"></i><i class="fas fa-robot" id="ai-icon" style="display: none;"></i><span id="aardio-document-home">aardio 文档</span></a>
<h1>thread.table 库模块帮助文档</h1>

<p><details>  <summary>用法说明</summary>  <p></p>

<p>线程共享表用于读写多线程共享值，以简化 thread.get,thread.set 的操作。
线程共享表本质上只是线程共享数据代理对象，自身并不存储这些线程共享数据。</p>

<p>线程共享表（thread.table ）基本规则：</p>

<ul>
<li>每次读取共享表的成员都会在当前线程复制一个新的副本。</li>
<li>写入直接表的直接成员才会写入线程共享资源。</li>
<li>不要将普通表直接覆盖替换线程共享表自身，应当存为子表</li>
<li>线程共享表的子表并非也是共享表，修改子表的成员并不能更新父级线程共享表。</li>
<li>线程共享表的下标操作符被重载为读写共享资源，不会与共享表的同名方法、属性发生冲突。</li>
<li>线程共享表的成员操作符虽然也能读写共享资源，但要避免覆盖同名的共享表方法与属性。</li>
<li>获取共享数组长度应当用线程共享表对象的 len 函数而不是 # 操作符。</li>
</ul>

<p>使用 thread.table 的示例 aardio 代码：</p>

<pre><code class="aardio language-aardio">
//注意先导入 thread.table 库再创建 thread.table 对象。
var thrdTable = thread.table()

//用下标读写键值，键名与对象的属性、函数名同名不会冲突。
thrdTable[&quot;b&quot;] = 34; 
thrdTable[&quot;c&quot;]= 56; 

//可以读写普通表，但子表并不是线程共享表。
thrdTable[&quot;d&quot;] = {}; 

//每次读取 thrdTable.d 都会得到新的副本
var localData = thrdTable[&quot;d&quot;];

//修改 localData 不会自动会同步到线程共享资源。
localData.tab = { name = &quot;name&quot; }

//下面这样只是修改子表的临时副本，子表不是线程共享表
thrdTable.d.tab = { name = &quot;name&quot; }

//只有修改线程共享表的直接成员，才会自动同步到线程共享资源
thrdTable[&quot;d&quot;] = localData;

//注意 # 操作符不适合用于线程共享表
var len = #thrdTable

//应当用 len 函数或 length 属性获取共享数组长度
len = thrdTable.len(); // 也可以用 thrdTable.

//线程共享表可作为线程函数的参数直接传入其他线程函数。
thread.invoke( 
    function(tab){
        var localData = thrdTable[&quot;d&quot;]; 
    },thrdTable
)
</code></pre>

<p></p></details></p>

<p><a id="thread"></a></p>

<h2>thread 成员列表</h2>

<p><a id="thread.table"></a></p>

<h3>thread.table()</h3>

<p>创建多线程共享表，返回对象可作为参数传入其他线程函数。<br>
可选使用参数 @1 指定线程共享变量名，<br>
省略参数  @1 则自动分配线程共享变量名。  </p>

<p>thread.var 以及 thread.table 分配的线程共享变量名上限为<br>
:0x3FFFFFFFFFFFFC0000000000000 个。<br>
应及时调用线程共享表的 release 函数释放对象与空闲的共享变量名  </p>

<p>可选用参数 @2 指定是否要重新初始化并创建新的共享表。<br>
如果未指定共享表名称，则总是重新初始化共享表  </p>

<p><a href="#threadTableObject">返回对象:threadTableObject</a></p>

<p><a id="thread.table"></a></p>

<h2>thread.table 成员列表</h2>

<p>多线程共享表。<br>
这是标准库模块，需要导入才能用。<br>
线程共享表用于读写多线程共享值，以简化 thread.get,thread.set 的操作。<br>
注意线程共享表本质上只是线程共享数据代理对象，自身并不存储这些线程共享数据。  </p>

<ul>
<li>每次读取共享表的成员都会在当前线程复制一个新的副本。<br></li>
<li>写入直接表的直接成员才会写入线程共享资源。<br></li>
<li>不要将普通表直接覆盖替换线程共享表自身，应当存为子表<br></li>
<li>线程共享表的子表并非也是共享表，修改子表的成员并不能更新父级线程共享表。<br></li>
<li>线程共享表的下标操作符被重载为读写共享资源，不会与共享表的同名方法、属性发生冲突。<br></li>
<li>线程共享表的成员操作符虽然也能读写共享资源，但要避免覆盖同名的共享表方法与属性。<br></li>
<li>获取共享数组长度应当用线程共享表对象的 len 函数而不是 # 操作符。</li>
</ul>

<p><a id="thread.table.array"></a></p>

<h3>thread.table.array()</h3>

<p>创建多线程共享数组，返回对象可作为参数传入其他线程函数。<br>
可选使用参数 @1 指定线程共享变量名，<br>
省略参数  @1 则自动分配线程共享变量名。  </p>

<p>thread.var 以及 thread.table 分配的线程共享变量名上限为<br>
:0x3FFFFFFFFFFFFC0000000000000 个。<br>
应及时调用线程共享表的 release 函数释放对象与空闲的共享变量名  </p>

<p>可选用参数 @2 指定是否要重新初始化并创建新的共享表。<br>
如果未指定共享表名称，则总是重新初始化共享表  </p>

<p><a href="#threadTableObject">返回对象:threadTableObject</a></p>

<p><a id="threadTableObject"></a></p>

<h2>threadTableObject 成员列表</h2>

<p><a id="threadTableObject.?"></a></p>

<h3>threadTableObject.?</h3>

<p>使用索引下标 [] 可读写共享表全部键值。<br>
使用成员属性操作符 . 则先访问对象的函数成员。  </p>

<p>不要拿普通表直接覆盖线程共享表本身，应存为共享表里的成员表。  </p>

<p>因为每次读取共享表的成员都会在当前线程复制一个新的副本。<br>
所以要修改线程共享表里面的子表，必须先读取到当前线程的本地变量。</p>

<p><a id="threadTableObject.add"></a></p>

<h3>threadTableObject.add(字段名,数值)</h3>

<p>修改共享表中参数@1指定名字的字段值。<br>
旧的字段值必须为 null 或数值。<br>
如果旧值为 null 则直接赋值为参数@2。<br>
如果旧值为数值则增加参数@2指定的数值。</p>

<p><a id="threadTableObject.append"></a></p>

<h3>threadTableObject.append()</h3>

<p>追加一个或多个数组到线程共享表,<br>
此函数内部使用table.append实现,规则相同,<br>
但无返回值</p>

<p><a id="threadTableObject.clear"></a></p>

<h3>threadTableObject.clear()</h3>

<p>清空共享表中的所有值</p>

<p><a id="threadTableObject.concat"></a></p>

<h3>threadTableObject.concat( tab2 )</h3>

<p>拼接多个table对象</p>

<p><a id="threadTableObject.count"></a></p>

<h3>threadTableObject.count()</h3>

<p>获取table成员总数</p>

<p><a id="threadTableObject.each"></a></p>

<h3>threadTableObject.each</h3>

<pre><code class="aardio language-aardio">for k,v in threadTableObject.each() {
    /*遍历表对象，k 为当前键，v 为当前值*/
}
</code></pre>

<p><a id="threadTableObject.get"></a></p>

<h3>threadTableObject.get(&quot;键名&quot;)</h3>

<p>读取成员值</p>

<p><a id="threadTableObject.getByNamespace"></a></p>

<h3>threadTableObject.getByNamespace(&quot;字符串参数&quot;)</h3>

<p>在指定表查找并返回成员</p>

<p><a id="threadTableObject.insert"></a></p>

<h3>threadTableObject.insert(要插入的值 )</h3>

<p>插入元素到table头部</p>

<p><a id="threadTableObject.insert"></a></p>

<h3>threadTableObject.insert(要插入的值,要插入的位置 )</h3>

<p>插入元素到指定位置</p>

<p><a id="threadTableObject.left"></a></p>

<h3>threadTableObject.left(len)</h3>

<p>返回table对象左侧开始返回指定个数的元素。</p>

<p><a id="threadTableObject.len"></a></p>

<h3>threadTableObject.len()</h3>

<p>返回 table 对象的数组元素长度，不含数组成员则返回 0。<br>
length 属性也可以返回数组长度，但表不是数组类型时返回 null。  </p>

<p>&num; 操作符仅用于计算表对象自身存储的数组成员，<br>
但线程共享仅仅是共享表的代理表，并不存储真正的共享数据。</p>

<p><a id="threadTableObject.lenByNamespace"></a></p>

<h3>threadTableObject.lenByNamespace(&quot;字符串参数&quot;)</h3>

<p>返回指定元素长度</p>

<p><a id="threadTableObject.length"></a></p>

<h3>threadTableObject.length</h3>

<p>数组返回数组长度，表不含数组成员且不是数组类型时返回 null。<br>
可使用 thread.table.array 创建数组类型的线程共享表。  </p>

<p>&num; 操作符仅用于计算表对象自身存储的数组成员，<br>
但线程共享仅仅是共享表的代理表，并不存储真正的共享数据。</p>

<p><a id="threadTableObject.name"></a></p>

<h3>threadTableObject.name</h3>

<p>共享表名字，不要改动</p>

<p><a id="threadTableObject.next"></a></p>

<h3>threadTableObject.next( key )</h3>

<p>迭代获取table的下一个键值对元素</p>

<p><a id="threadTableObject.next"></a></p>

<h3>threadTableObject.next()</h3>

<p>获取table的第一个键值对元素</p>

<p><a id="threadTableObject.pop"></a></p>

<h3>threadTableObject.pop()</h3>

<p>在顺序数组尾部弹出一个或多个元素并作为返回值</p>

<p><a id="threadTableObject.push"></a></p>

<h3>threadTableObject.push()</h3>

<p>在顺序数组尾部压入一个或多个元素,返回数组大小</p>

<p><a id="threadTableObject.push"></a></p>

<h3>threadTableObject.push(v1,v2,v3,...)</h3>

<p>在顺序数组尾部压入多个元素,返回数组大小</p>

<p><a id="threadTableObject.range"></a></p>

<h3>threadTableObject.range()</h3>

<p>返回table数组的最小索引,最大索引<br>
min,max=tab.range();</p>

<p><a id="threadTableObject.release"></a></p>

<h3>threadTableObject.release()</h3>

<p>释放线程共享表，释放后不应当再使用</p>

<p><a id="threadTableObject.remove"></a></p>

<h3>threadTableObject.remove( )</h3>

<p>在table头部移除元素</p>

<p><a id="threadTableObject.remove"></a></p>

<h3>threadTableObject.remove(位置 )</h3>

<p>在表中指定位置移除元素</p>

<p><a id="threadTableObject.reverse"></a></p>

<h3>threadTableObject.reverse()</h3>

<p>table数组倒序排列。</p>

<p><a id="threadTableObject.right"></a></p>

<h3>threadTableObject.right(len</h3>

<p>返回table对象右侧开始返回指定个数的元素</p>

<p><a id="threadTableObject.set"></a></p>

<h3>threadTableObject.set(&quot;键名&quot;,值)</h3>

<p>写入成员值</p>

<p><a id="threadTableObject.setByNamespace"></a></p>

<h3>threadTableObject.setByNamespace(&quot;字符串参数&quot;,新值)</h3>

<p>参数一指定表内名字空间路径,如果不存在则则创建此表内名字空间,<br>
支持索引操作符,可以使用[]空索引实现在数组尾部添加值<br>
参数二指定需要设置的值,如果不指定则创建空表并赋值</p>

<p><a id="threadTableObject.shift"></a></p>

<h3>threadTableObject.shift(移除数目)</h3>

<p>自数组头部移除并返回指定个数成员,<br>
参数默认为1</p>

<p><a id="threadTableObject.sort"></a></p>

<h3>threadTableObject.sort( )</h3>

<p>排序</p>

<p><a id="threadTableObject.sort"></a></p>

<h3>threadTableObject.sort( comProc )</h3>

<p>排序,comProc指定用于比较元素大小的函数</p>

<p><a id="threadTableObject.tostring"></a></p>

<h3>threadTableObject.tostring()</h3>

<p>获取table的字符串表达式</p>

<p><a id="threadTableObject.unpack"></a></p>

<h3>threadTableObject.unpack()</h3>

<p>返回表中所有的元素<br>
a,b,c,d,e = tab.unpack();</p>

<p><a id="threadTableObject.unshift"></a></p>

<h3>threadTableObject.unshift(要插入的一个或多个元素)</h3>

<p>插入一个或多个元素到数组头部,返回数组长度</p>

<p><a href="table.md" tppabs="https://www.aardio.com/zh-cn/doc/library-reference/thread/table.md">Markdown 格式</a></p>

</body> 
</html>